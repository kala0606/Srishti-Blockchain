<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Srishti Blockchain - Join the Timeline</title>
    
    <!-- External Libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- QR Code Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    
    <!-- Ed25519 Library for deterministic key generation -->
    <script src="https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/index.js"></script>
    
    <!-- Blockchain Core (load in order) -->
    <script src="src/core/Hasher.js"></script>
    <script src="src/core/Event.js"></script>
    <script src="src/core/MerkleTree.js"></script>
    <script src="src/core/BlockHeader.js"></script>
    <script src="src/core/BlockBody.js"></script>
    <script src="src/core/Block.js"></script>
    <script src="src/core/Chain.js"></script>
    <script src="src/core/KarmaManager.js"></script>
    <script src="src/core/LightClient.js"></script>
    <script src="src/crypto/Keys.js"></script>
    <script src="src/crypto/BIP39.js"></script>
    <script src="src/crypto/Recovery.js"></script>
    <script src="src/storage/IndexedDBStore.js"></script>
    <script src="src/consensus/ProofOfParticipation.js"></script>
    <script src="src/p2p/Protocol.js"></script>
    <script src="src/p2p/WebSocketClient.js"></script>
    <script src="src/p2p/Network.js"></script>
    <script src="src/discovery/QRCode.js"></script>
    <script src="src/ui/BlockchainAdapter.js"></script>
    <script src="src/ui/GlowCalculator.js"></script>
    
    <!-- QR Scanner (blockchain-compatible) -->
    <script src="docs/qr-scanner-blockchain.js"></script>
    
    <!-- Configuration -->
    <script src="config.js"></script>
    
    <!-- Main App -->
    <script src="app.js"></script>
    
    <!-- Configuration: Force use of Fly.io signaling server even on localhost -->
    <script>
        // Always use Fly.io signaling server for WebSocket connections
        // This ensures P2P networking works on both localhost and GitHub Pages
        // WebSocket Relay Server URL (all P2P messages flow through this server)
        window.SRISHTI_RELAY_URL = 'wss://srishti-signaling.fly.dev';
        // Backward compatibility
        window.SRISHTI_SIGNALING_URL = window.SRISHTI_RELAY_URL;
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Syne:wght@400;500;600;700;800&display=swap');
        
        :root {
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --accent: #ffffff;
            --accent-muted: rgba(255, 255, 255, 0.7);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --blur-strength: 20px;
        }
        
        /* SVG Icon Styles */
        .icon {
            width: 1em;
            height: 1em;
            display: inline-block;
            fill: currentColor;
            vertical-align: middle;
        }
        
        .icon-sm {
            width: 0.875em;
            height: 0.875em;
        }
        
        .icon-lg {
            width: 1.25em;
            height: 1.25em;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Mobile touch improvements for all buttons */
        button {
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            overflow: hidden;
            font-family: 'Outfit', sans-serif;
            background: #050510;
        }

        /* Subtle background */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.03) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.02) 0%, transparent 40%);
            animation: blobMove 25s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes blobMove {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(2%, -2%) rotate(3deg); }
            50% { transform: translate(-1%, 3%) rotate(-2deg); }
            75% { transform: translate(-3%, -1%) rotate(2deg); }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        /* Glass Panel Base Styles */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--blur-strength));
            -webkit-backdrop-filter: blur(var(--blur-strength));
            border: 1px solid var(--glass-border);
            box-shadow: 
                0 8px 32px var(--glass-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Onboarding Modal */
        #onboarding-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.7);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        #onboarding-modal.active {
            display: flex;
        }

        .onboarding-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 48px 40px;
            max-width: 420px;
            width: 90%;
            color: var(--text-primary);
            text-align: center;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                0 1px 0 rgba(255, 255, 255, 0.1) inset;
            animation: modalAppear 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }
        
        .onboarding-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        }
        
        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(30px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .onboarding-logo {
            font-family: 'Syne', sans-serif;
            font-size: 2.8em;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .onboarding-tagline {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 32px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 300;
        }

        .onboarding-input-group {
            margin-bottom: 28px;
        }

        .onboarding-input-group label {
            display: block;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85em;
            margin-bottom: 10px;
            text-align: left;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .onboarding-input {
            width: 100%;
            padding: 18px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 1.1em;
            font-family: 'Outfit', sans-serif;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .onboarding-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 0 0 4px rgba(255, 255, 255, 0.1),
                0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .onboarding-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .onboarding-btn {
            background: var(--text-primary);
            color: #000;
            border: none;
            padding: 18px 48px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
            letter-spacing: 1px;
            text-transform: uppercase;
            /* Mobile touch improvements */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }

        .onboarding-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        .onboarding-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .onboarding-divider {
            display: flex;
            align-items: center;
            margin: 24px 0;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .onboarding-divider::before,
        .onboarding-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
        }
        
        .onboarding-divider span {
            padding: 0 16px;
        }
        
        .onboarding-recover-btn {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 14px 32px;
            border-radius: 50px;
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            /* Mobile touch improvements */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }
        
        .onboarding-recover-btn .icon {
            width: 16px;
            height: 16px;
        }
        
        .onboarding-recover-btn:hover {
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }

        .join-info {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            padding: 18px;
            margin-bottom: 28px;
            backdrop-filter: blur(10px);
        }

        .join-info p {
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
            font-size: 0.9em;
        }

        .join-info .parent-name {
            font-weight: 600;
            font-size: 1.15em;
            color: var(--text-primary);
            margin-top: 4px;
        }

        /* Parent select dropdown styling */
        #parent-select option {
            background: #1a1a2e;
            color: #fff;
            padding: 10px;
        }

        /* Floating Action Buttons */
        .fab-container {
            position: fixed;
            bottom: 32px;
            right: 32px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 500;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            font-size: 22px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            /* Mobile touch improvements */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }
        
        .fab .icon {
            width: 24px;
            height: 24px;
        }

        .fab:hover {
            transform: scale(1.1) translateY(-4px);
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
        }

        .fab.primary {
            width: 56px;
            height: 56px;
            background: var(--text-primary);
            border: none;
            color: #000;
            font-size: 22px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .fab.primary:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            opacity: 0.9;
        }

        /* QR Modal */
        #qr-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.8);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #qr-modal.active {
            display: flex;
        }

        .qr-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            color: var(--text-primary);
            text-align: center;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: modalAppear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
        }

        .qr-close {
            position: absolute;
            top: 18px;
            right: 22px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .qr-title {
            font-family: 'Syne', sans-serif;
            color: var(--text-primary);
            margin: 0 0 8px 0;
            font-size: 1.6em;
            font-weight: 700;
        }

        .qr-subtitle {
            color: var(--text-secondary);
            margin: 0 0 28px 0;
            font-size: 0.9em;
        }

        #qr-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 28px;
            min-height: 240px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #qr-display canvas,
        #qr-display img {
            border-radius: 12px;
        }

        .qr-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .qr-btn {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 14px 24px;
            border-radius: 50px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            /* Mobile touch improvements */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }
        
        .qr-btn .icon {
            width: 16px;
            height: 16px;
        }

        .qr-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .qr-btn.primary {
            background: var(--text-primary);
            color: #000;
            border: none;
            font-weight: 600;
        }
        
        .qr-btn.primary:hover {
            opacity: 0.9;
        }

        /* Node Info Modal */
        #node-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.8);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #node-modal.active {
            display: flex;
        }

        .node-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: var(--text-primary);
            position: relative;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-align: center;
            animation: modalAppear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .node-close {
            position: absolute;
            top: 18px;
            right: 22px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .node-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .node-info-badge {
            white-space: nowrap;
        }

        .node-token-item {
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: left;
            transition: all 0.2s ease;
        }

        .node-token-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .node-token-title {
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .node-token-issuer {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
        }

        .node-token-date {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Mobile responsive for node modal */
        @media (max-width: 768px) {
            .node-content {
                padding: 30px 24px;
                max-width: 95%;
                border-radius: 24px;
            }

            .node-stats {
                gap: 16px;
            }

            #node-tokens-list {
                max-height: 150px;
            }

            /* Custom scrollbar for mobile */
            .node-content::-webkit-scrollbar,
            #node-tokens-list::-webkit-scrollbar {
                width: 6px;
            }

            .node-content::-webkit-scrollbar-track,
            #node-tokens-list::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
            }

            .node-content::-webkit-scrollbar-thumb,
            #node-tokens-list::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 3px;
            }

            .node-content::-webkit-scrollbar-thumb:hover,
            #node-tokens-list::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }

        /* Mint Token Modal */
        #mint-token-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.8);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #mint-token-modal.active {
            display: flex;
        }

        .mint-token-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            color: var(--text-primary);
            position: relative;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: modalAppear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .mint-token-close {
            position: absolute;
            top: 18px;
            right: 22px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mint-token-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        #mint-token-form input:focus,
        #mint-token-form select:focus,
        #mint-token-form textarea:focus {
            border-color: rgba(147, 51, 234, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .mint-token-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mint-token-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(147, 51, 234, 0.4);
        }

        .node-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            font-weight: 700;
            color: #000;
            margin: 0 auto 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            font-family: 'Syne', sans-serif;
        }

        .node-name {
            color: var(--text-primary);
            margin: 0 0 8px 0;
            font-size: 1.8em;
            font-family: 'Syne', sans-serif;
            font-weight: 700;
        }

        .node-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 28px 0;
            padding: 24px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .node-stat {
            text-align: center;
        }

        .node-stat-value {
            font-size: 2.2em;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Syne', sans-serif;
        }

        .node-stat-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }

        .node-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .node-status.online {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .node-status.offline {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .node-status.online .status-dot {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 12px currentColor;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        /* Stats Bar */
        .stats-bar {
            position: fixed;
            top: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .stat-icon {
            width: 1.1em;
            height: 1.1em;
            display: inline-block;
            fill: currentColor;
            color: var(--text-primary);
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.15em;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        /* Sync Progress Bar */
        .sync-progress-bar {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            padding: 16px 20px;
            min-width: 320px;
            max-width: 400px;
            z-index: 100;
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: fadeIn 0.3s ease;
        }

        .sync-progress-content {
            display: flex;
            align-items: flex-start;
            gap: 14px;
        }

        .sync-progress-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #60A5FA;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .sync-progress-info {
            flex: 1;
            min-width: 0;
        }

        .sync-progress-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 10px;
        }

        .sync-progress-text > span:first-child {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95em;
        }

        .sync-progress-details {
            color: var(--text-secondary);
            font-size: 0.85em;
        }

        .sync-progress-track {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .sync-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #60A5FA, #9333EA);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
            position: relative;
            overflow: hidden;
        }

        .sync-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .sync-progress-bar {
                top: 80px;
                right: 16px;
                left: 16px;
                min-width: auto;
                max-width: none;
            }
        }

        /* Chain Status Indicator - shows when behind or syncing */
        .chain-status-indicator {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 12px;
            padding: 10px 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 150;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            animation: fadeIn 0.3s ease;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chain-status-indicator:hover {
            background: rgba(251, 191, 36, 0.25);
            transform: translateX(-50%) scale(1.02);
        }

        .chain-status-indicator.syncing {
            background: rgba(96, 165, 250, 0.15);
            border-color: rgba(96, 165, 250, 0.4);
        }

        .chain-status-indicator.synced {
            background: rgba(52, 211, 153, 0.15);
            border-color: rgba(52, 211, 153, 0.4);
        }

        .chain-status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FBBF24;
        }

        .chain-status-indicator.syncing .chain-status-icon {
            color: #60A5FA;
            animation: spin 1.5s linear infinite;
        }

        .chain-status-indicator.synced .chain-status-icon {
            color: #34D399;
        }

        .chain-status-text {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        .chain-status-action {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.6);
            padding-left: 8px;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 768px) {
            .chain-status-indicator {
                top: 80px;
                left: 16px;
                right: 16px;
                transform: none;
                justify-content: center;
            }
            .chain-status-indicator:hover {
                transform: scale(1.02);
            }
        }

        /* Your Node Indicator */
        .your-node-indicator {
            position: fixed;
            bottom: 32px;
            left: 32px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 16px 22px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.3s ease;
            /* Mobile touch improvements */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            user-select: none;
            -webkit-user-select: none;
        }
        
        .your-node-indicator:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 
                0 16px 50px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.12);
        }

        .your-node-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #000;
            font-weight: 700;
            font-family: 'Syne', sans-serif;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .your-node-info h3 {
            color: var(--text-primary);
            margin: 0 0 4px 0;
            font-size: 1.05em;
            font-weight: 600;
        }

        .your-node-info p {
            color: var(--text-secondary);
            margin: 0;
            font-size: 0.85em;
        }

        /* Loading State */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050510;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 30% 70%, rgba(255, 255, 255, 0.02) 0%, transparent 40%),
                radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.02) 0%, transparent 40%);
            animation: blobMove 25s ease-in-out infinite;
        }

        .loading-logo {
            font-family: 'Syne', sans-serif;
            font-size: 3.5em;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 40px;
            letter-spacing: -2px;
            position: relative;
            z-index: 1;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: relative;
            z-index: 1;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            margin-top: 24px;
            font-size: 0.9em;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }

        /* Guest Loading Indicator */
        #guest-indicator {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #guest-indicator.loading {
            pointer-events: none;
        }
        
        .guest-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .guest-check {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 8px;
            vertical-align: middle;
            color: #4ade80;
            animation: checkPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes checkPop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .guest-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.8), rgba(59, 130, 246, 0.8));
            border-radius: 0 0 12px 12px;
            transition: width 0.3s ease;
        }
        
        /* Skeleton loaders */
        .skeleton {
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.04) 0%,
                rgba(255, 255, 255, 0.08) 50%,
                rgba(255, 255, 255, 0.04) 100%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 8px;
        }
        
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .skeleton-text {
            height: 14px;
            margin-bottom: 8px;
        }
        
        .skeleton-text.sm {
            height: 12px;
            width: 60%;
        }
        
        .skeleton-circle {
            border-radius: 50%;
        }
        
        /* Pulse animation for sync status */
        .sync-pulse {
            animation: syncPulse 2s ease-in-out infinite;
        }
        
        @keyframes syncPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        /* Dashboard loading state */
        .dashboard-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            gap: 16px;
        }
        
        .dashboard-loading .loading-spinner {
            width: 32px;
            height: 32px;
        }
        
        .dashboard-loading-text {
            color: var(--text-secondary);
            font-size: 0.85em;
            letter-spacing: 0.5px;
        }

        /* Welcome Animation for new nodes */
        .welcome-burst {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2000;
        }

        .welcome-text {
            font-family: 'Syne', sans-serif;
            font-size: 3.5em;
            font-weight: 800;
            color: var(--text-primary);
            animation: welcomeAppear 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes welcomeAppear {
            0% { 
                opacity: 0; 
                transform: scale(0.5);
                filter: blur(10px);
            }
            20% { 
                opacity: 1; 
                transform: scale(1.15);
                filter: blur(0);
            }
            40% { transform: scale(1); }
            80% { opacity: 1; }
            100% { 
                opacity: 0; 
                transform: scale(1.3);
                filter: blur(5px);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* ============================================
           USER DASHBOARD STYLES
           ============================================ */
        
        #dashboard-panel {
            position: fixed;
            top: 0;
            right: -450px;
            width: 420px;
            height: 100vh;
            background: linear-gradient(180deg, rgba(12, 12, 25, 0.95) 0%, rgba(8, 8, 18, 0.98) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 800;
            transition: right 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: -20px 0 60px rgba(0, 0, 0, 0.5);
        }
        
        #dashboard-panel.open {
            right: 0;
        }
        
        #dashboard-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.03) 0%, transparent 100%);
            pointer-events: none;
        }
        
        .dashboard-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .dashboard-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: rotate(90deg);
        }
        
        .dashboard-content {
            padding: 32px 28px;
            padding-top: 24px;
        }
        
        /* Profile Header */
        .dashboard-profile {
            text-align: center;
            padding-bottom: 28px;
            margin-bottom: 28px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            position: relative;
        }
        
        .dashboard-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            font-weight: 800;
            color: #000;
            margin: 0 auto 18px;
            font-family: 'Syne', sans-serif;
            box-shadow: 
                0 8px 32px rgba(255, 215, 0, 0.3),
                0 0 0 4px rgba(255, 215, 0, 0.1);
            position: relative;
        }
        
        .dashboard-avatar::after {
            content: '';
            position: absolute;
            bottom: 6px;
            right: 6px;
            width: 18px;
            height: 18px;
            background: #00ff88;
            border-radius: 50%;
            border: 3px solid #0c0c19;
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.5);
        }
        
        .dashboard-avatar.offline::after {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: none;
        }
        
        .dashboard-name {
            font-family: 'Syne', sans-serif;
            font-size: 1.8em;
            font-weight: 700;
            color: #fff;
            margin: 0 0 6px 0;
            letter-spacing: -0.5px;
        }
        
        .dashboard-subtitle {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .dashboard-subtitle .node-id {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(255, 255, 255, 0.06);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        /* Stats Grid */
        .dashboard-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 14px;
            margin-bottom: 28px;
        }
        
        @media (max-width: 768px) {
            .dashboard-stats {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            border-color: rgba(255, 255, 255, 0.12);
        }
        
        .stat-card.highlight {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 165, 0, 0.05) 100%);
            border-color: rgba(255, 215, 0, 0.2);
        }
        
        .stat-card.highlight:hover {
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        .stat-card-icon {
            font-size: 1.6em;
            margin-bottom: 8px;
            opacity: 0.9;
        }
        
        .stat-card-value {
            font-family: 'Syne', sans-serif;
            font-size: 2em;
            font-weight: 700;
            color: #fff;
            line-height: 1;
            margin-bottom: 6px;
        }
        
        .stat-card.highlight .stat-card-value {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-card-label {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        
        /* Section Headers */
        .dashboard-section {
            margin-bottom: 24px;
        }
        
        .dashboard-section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .dashboard-section-title {
            font-family: 'Syne', sans-serif;
            font-size: 0.9em;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .dashboard-section-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), transparent);
        }
        
        /* Network Tree Mini */
        .network-tree-mini {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 20px;
        }
        
        .network-node {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }
        
        .network-node:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .network-node.parent {
            border-left: 3px solid rgba(255, 215, 0, 0.5);
        }
        
        .network-node.self {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .network-node.child {
            margin-left: 24px;
            border-left: 3px solid rgba(0, 255, 136, 0.4);
        }
        
        .network-node-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: #fff;
            font-family: 'Syne', sans-serif;
        }
        
        .network-node.self .network-node-avatar {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
        }
        
        .network-node-info {
            flex: 1;
        }
        
        .network-node-name {
            font-weight: 600;
            color: #fff;
            font-size: 0.95em;
        }
        
        .network-node-role {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .network-node-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .network-node-status.online {
            background: #00ff88;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }
        
        /* Activity Timeline */
        .activity-timeline {
            position: relative;
        }
        
        .activity-timeline::before {
            content: '';
            position: absolute;
            left: 15px;
            top: 20px;
            bottom: 20px;
            width: 2px;
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.3), rgba(255, 255, 255, 0.1), transparent);
        }
        
        .activity-item {
            display: flex;
            gap: 16px;
            padding: 12px 0;
            position: relative;
        }
        
        .activity-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
            z-index: 1;
        }
        
        .activity-item:first-child .activity-dot {
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.4);
        }
        
        .activity-content {
            flex: 1;
            padding-top: 4px;
        }
        
        .activity-title {
            color: #fff;
            font-size: 0.9em;
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .activity-time {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.4);
        }
        
        /* Blockchain Info */
        .blockchain-info {
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.08) 0%, rgba(100, 100, 255, 0.02) 100%);
            border: 1px solid rgba(100, 100, 255, 0.15);
            border-radius: 16px;
            padding: 20px;
        }
        
        .blockchain-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .blockchain-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .blockchain-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85em;
        }
        
        .blockchain-value {
            color: #fff;
            font-weight: 600;
            font-family: 'JetBrains Mono', 'Outfit', monospace;
            font-size: 0.9em;
        }
        
        .blockchain-value.hash {
            font-size: 0.75em;
            color: rgba(100, 180, 255, 0.9);
        }
        
        /* Dashboard Actions */
        .dashboard-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.06);
        }
        
        .dashboard-btn {
            flex: 1;
            padding: 14px 20px;
            border-radius: 12px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .dashboard-btn.primary {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: none;
            color: #000;
        }
        
        .dashboard-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(255, 215, 0, 0.3);
        }
        
        .dashboard-btn.secondary {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #fff;
        }
        
        .dashboard-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        /* Empty State */
        .dashboard-empty {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .dashboard-empty-icon {
            font-size: 3em;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .dashboard-empty-title {
            font-family: 'Syne', sans-serif;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }
        
        /* Soulbound Tokens */
        .soulbound-grid {
            display: grid;
            gap: 12px;
        }
        
        .soulbound-token {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(79, 70, 229, 0.1));
            border: 1px solid rgba(147, 51, 234, 0.25);
            border-radius: 12px;
            transition: all 0.3s ease;
        }
        
        .soulbound-token:hover {
            transform: translateX(4px);
            border-color: rgba(147, 51, 234, 0.4);
        }
        
        .soulbound-icon {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: linear-gradient(135deg, #9333EA, #4F46E5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            flex-shrink: 0;
        }
        
        .soulbound-info {
            flex: 1;
            min-width: 0;
        }
        
        .soulbound-name {
            font-weight: 600;
            font-size: 0.95em;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .soulbound-issuer {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 2px;
        }
        
        .soulbound-badge {
            font-size: 0.7em;
            padding: 4px 8px;
            border-radius: 20px;
            background: rgba(147, 51, 234, 0.3);
            color: rgba(200, 150, 255, 1);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Governance Proposals */
        .proposals-list {
            display: grid;
            gap: 12px;
        }
        
        .proposal-card {
            padding: 16px;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 12px;
            transition: all 0.3s ease;
        }
        
        .proposal-card:hover {
            border-color: rgba(34, 197, 94, 0.35);
        }
        
        .proposal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .proposal-id {
            font-family: 'Syne', sans-serif;
            font-weight: 600;
            color: rgba(34, 197, 94, 0.9);
            font-size: 0.85em;
        }
        
        .proposal-status {
            font-size: 0.7em;
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .proposal-status.active {
            background: rgba(34, 197, 94, 0.25);
            color: #22C55E;
        }
        
        .proposal-status.ended {
            background: rgba(156, 163, 175, 0.2);
            color: #9CA3AF;
        }
        
        .proposal-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.4;
            margin-bottom: 12px;
        }
        
        .proposal-meta {
            display: flex;
            gap: 16px;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .proposal-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Social Recovery / Guardians */
        .guardians-container {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 16px;
        }
        
        .guardians-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .guardians-threshold {
            font-size: 0.85em;
            color: rgba(255, 215, 0, 0.9);
            font-weight: 600;
        }
        
        .guardians-count {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .guardians-list {
            display: grid;
            gap: 8px;
        }
        
        .guardian-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.1);
            border-radius: 10px;
        }
        
        .guardian-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.15));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
        }
        
        .guardian-address {
            flex: 1;
            font-family: monospace;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .setup-recovery-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.1));
            border: 1px dashed rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            color: rgba(255, 215, 0, 0.9);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .setup-recovery-btn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.15));
            border-color: rgba(255, 215, 0, 0.5);
        }
        
        /* Institution Section */
        .role-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .role-badge.root {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.25), rgba(255, 165, 0, 0.2));
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.4);
        }
        
        .role-badge.institution {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(79, 70, 229, 0.15));
            color: #A78BFA;
            border: 1px solid rgba(147, 51, 234, 0.3);
        }
        
        .role-badge.user {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .institution-info {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.1), rgba(79, 70, 229, 0.05));
            border: 1px solid rgba(147, 51, 234, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .institution-name {
            font-weight: 600;
            font-size: 1em;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .institution-category {
            font-size: 0.8em;
            color: rgba(167, 139, 250, 0.9);
        }
        
        .register-institution-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(79, 70, 229, 0.1));
            border: 1px dashed rgba(147, 51, 234, 0.4);
            border-radius: 12px;
            color: rgba(167, 139, 250, 1);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .register-institution-btn:hover {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.25), rgba(79, 70, 229, 0.15));
            border-color: rgba(147, 51, 234, 0.6);
        }
        
        /* Admin Panel - Pending Institutions */
        .admin-section {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(255, 165, 0, 0.04));
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .admin-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
            font-family: 'Syne', sans-serif;
            font-size: 0.85em;
            font-weight: 600;
            color: rgba(255, 215, 0, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .pending-institution {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 10px;
        }
        
        .pending-institution:last-child {
            margin-bottom: 0;
        }
        
        .pending-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .pending-name {
            font-weight: 600;
            color: #fff;
        }
        
        .pending-category {
            font-size: 0.75em;
            padding: 3px 8px;
            border-radius: 12px;
            background: rgba(147, 51, 234, 0.2);
            color: rgba(167, 139, 250, 0.9);
        }
        
        .pending-id {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.4);
            font-family: monospace;
            margin-bottom: 10px;
        }
        
        .pending-actions {
            display: flex;
            gap: 8px;
        }
        
        .pending-actions button {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .approve-btn {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.4);
            color: #22C55E;
        }
        
        .approve-btn:hover {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(16, 185, 129, 0.2));
        }
        
        .reject-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #EF4444;
        }
        
        .reject-btn:hover {
            background: rgba(239, 68, 68, 0.25);
        }
        
        /* Responsive */
        @media (max-width: 480px) {
            #dashboard-panel {
                width: 100%;
                right: -100%;
            }
            
            .dashboard-stats {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .stat-card {
                padding: 16px;
            }
            
            .stat-card-value {
                font-size: 1.6em;
            }
        }
    </style>
</head>

<body>
    <div id="container"></div>
    
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loading-logo">SRISHTI</div>
        <div class="loading-spinner"></div>
        <p class="loading-text" id="loading-status">Initializing...</p>
        <div class="loading-substatus" id="loading-substatus" style="
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.75em;
            margin-top: 8px;
            letter-spacing: 0.5px;
        "></div>
    </div>

    <!-- Onboarding Modal -->
    <div id="onboarding-modal">
        <div class="onboarding-content">
            <div class="onboarding-logo">SRISHTI</div>
            <p class="onboarding-tagline">JOIN THE BLOCKCHAIN TIMELINE</p>
            
            <div id="join-parent-info" class="join-info" style="display: none;">
                <p>You're joining as a node under</p>
                <p class="parent-name" id="parent-name-display">...</p>
            </div>
            
            <!-- Parent selection when joining without QR code -->
            <div id="select-parent-section" class="join-info" style="display: none;">
                <p style="margin-bottom: 12px;">Choose who to join under:</p>
                <select id="parent-select" style="
                    width: 100%;
                    padding: 12px 16px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    border-radius: 12px;
                    color: #fff;
                    font-size: 1em;
                    font-family: 'Outfit', sans-serif;
                    cursor: pointer;
                    appearance: none;
                    -webkit-appearance: none;
                    background-image: url('data:image/svg+xml;utf8,<svg fill=\"white\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 10l5 5 5-5z\"/></svg>');
                    background-repeat: no-repeat;
                    background-position: right 12px center;
                    background-size: 20px;
                ">
                    <option value="">Select a node...</option>
                </select>
                <p style="margin-top: 10px; font-size: 0.85em; opacity: 0.6;">
                     Tip: Scan someone's QR code to join directly under them
                </p>
            </div>
            
            <div class="onboarding-input-group">
                <label for="user-name">YOUR NAME</label>
                <input type="text" id="user-name" class="onboarding-input" 
                    placeholder="Enter your name to join" maxlength="30" autocomplete="off">
            </div>
            
            <button id="join-btn" class="onboarding-btn" disabled>
                Enter the Timeline
            </button>
            
            <div class="onboarding-divider">
                <span>or</span>
            </div>
            
            <button id="recover-node-btn" class="onboarding-recover-btn">
                <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
                Recover Existing Node
            </button>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-modal">
        <div class="qr-content" style="position: relative;">
            <button class="qr-close">&times;</button>
            <h2 class="qr-title">Your Invite QR</h2>
            <p class="qr-subtitle">Others can scan this to join as your node</p>
            <div id="qr-display"></div>
            <div class="qr-actions">
                <button id="share-qr-btn" class="qr-btn primary">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                        <polyline points="16 6 12 2 8 6"></polyline>
                        <line x1="12" y1="2" x2="12" y2="15"></line>
                    </svg>
                    Share
                </button>
                <button id="copy-link-btn" class="qr-btn">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    Copy Link
                </button>
            </div>
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button id="show-recovery-btn" class="qr-btn" style="width: 100%;">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Show Recovery Phrase
                </button>
            </div>
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button id="download-chain-btn" class="qr-btn" style="width: 100%;">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download Chain Data
                </button>
            </div>
        </div>
    </div>

    <!-- Node Info Modal -->
    <div id="node-modal">
        <div class="node-content">
            <button class="node-close">&times;</button>
            <div class="node-avatar" id="node-avatar">?</div>
            <h2 class="node-name" id="node-name">Node Name</h2>
            <div class="node-status" id="node-status">
                <span class="status-dot"></span>
                <span id="node-status-text">Offline</span>
            </div>
            
            <!-- Role and Rank Section -->
            <div class="node-info-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; gap: 16px; justify-content: center; flex-wrap: wrap;">
                    <div class="node-info-badge" id="node-role-badge" style="padding: 8px 16px; background: rgba(147, 51, 234, 0.2); border: 1px solid rgba(147, 51, 234, 0.4); border-radius: 20px; font-size: 0.85em; font-weight: 600;">
                        <span id="node-role-text">Role</span>
                    </div>
                    <div class="node-info-badge" id="node-rank-badge" style="padding: 8px 16px; background: rgba(255, 215, 0, 0.2); border: 1px solid rgba(255, 215, 0, 0.4); border-radius: 20px; font-size: 0.85em; font-weight: 600;">
                        <span id="node-rank-text">Rank</span>
                    </div>
                </div>
            </div>
            
            <div class="node-stats">
                <div class="node-stat">
                    <div class="node-stat-value" id="node-children">0</div>
                    <div class="node-stat-label">Recruited</div>
                </div>
                <div class="node-stat">
                    <div class="node-stat-value" id="node-joined">-</div>
                    <div class="node-stat-label">Joined</div>
                </div>
            </div>
            
            <!-- Institution Info Section -->
            <div id="node-institution-section" style="display: none; margin-top: 20px; padding: 16px; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 12px;">
                <div style="font-size: 0.85em; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px;">Institution</div>
                <div id="node-institution-name" style="font-weight: 600; font-size: 1.05em; margin-bottom: 4px;"></div>
                <div id="node-institution-category" style="font-size: 0.85em; color: rgba(255, 255, 255, 0.7);"></div>
            </div>
            
            <!-- Soulbound Tokens Section -->
            <div id="node-tokens-section" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="font-size: 0.9em; font-weight: 600; margin-bottom: 12px; color: rgba(255, 255, 255, 0.8);"> Soulbound Tokens</div>
                <div id="node-tokens-list" style="display: flex; flex-direction: column; gap: 10px; max-height: 200px; overflow-y: auto; padding-right: 8px;">
                    <!-- Tokens will be populated here -->
                </div>
            </div>
            
            <div id="node-modal-actions" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button id="request-parent-btn" class="node-action-btn" style="display: none; width: 100%; padding: 12px; background: linear-gradient(135deg, #9333EA, #4F46E5); border: none; border-radius: 8px; color: white; font-size: 0.95em; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px; margin-right: 8px; vertical-align: middle;">
                        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="8.5" cy="7" r="4"></circle>
                        <line x1="20" y1="8" x2="20" y2="14"></line>
                        <line x1="23" y1="11" x2="17" y2="11"></line>
                    </svg>
                    Request Parent Connection
                </button>
            </div>
        </div>
    </div>

    <!-- Mint Token Modal -->
    <div id="mint-token-modal">
        <div class="mint-token-content">
            <button class="mint-token-close">&times;</button>
            <h2 style="margin: 0 0 8px 0; font-size: 1.5em; font-weight: 700; color: var(--text-primary);"> Issue Token</h2>
            <p style="margin: 0 0 24px 0; color: rgba(255, 255, 255, 0.6); font-size: 0.9em;">Mint a soulbound token to a user</p>
            
            <form id="mint-token-form">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.8); font-size: 0.9em; font-weight: 500;">Recipient *</label>
                    <select id="mint-recipient" required style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; outline: none; transition: all 0.3s ease;">
                        <option value="">Select a recipient...</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.8); font-size: 0.9em; font-weight: 500;">Achievement ID *</label>
                    <input type="text" id="mint-achievement-id" required placeholder="e.g., DEGREE_2026_CSE" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; outline: none; transition: all 0.3s ease;">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.8); font-size: 0.9em; font-weight: 500;">Title *</label>
                    <input type="text" id="mint-title" required placeholder="e.g., B.Tech Computer Science" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; outline: none; transition: all 0.3s ease;">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.8); font-size: 0.9em; font-weight: 500;">Description</label>
                    <textarea id="mint-description" placeholder="Optional description..." rows="3" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; outline: none; transition: all 0.3s ease; resize: vertical; font-family: inherit;"></textarea>
                </div>
                
                <div style="margin-bottom: 24px;">
                    <label style="display: flex; align-items: center; gap: 8px; color: rgba(255, 255, 255, 0.8); font-size: 0.9em; cursor: pointer;">
                        <input type="checkbox" id="mint-revocable" checked style="width: 18px; height: 18px; cursor: pointer;">
                        <span>Revocable (can be revoked later)</span>
                    </label>
                </div>
                
                <div style="display: flex; gap: 12px;">
                    <button type="button" class="mint-token-cancel" style="flex: 1; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">Cancel</button>
                    <button type="submit" class="mint-token-submit" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #9333EA, #4F46E5); border: none; border-radius: 8px; color: white; font-size: 0.95em; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">Issue Token</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar">
        <div class="stat-item">
            <svg class="stat-icon icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
            </svg>
            <span class="stat-value" id="total-nodes">0</span>
            <span class="stat-label">nodes</span>
        </div>
        <div class="stat-item">
            <svg class="stat-icon icon" viewBox="0 0 24 24" fill="currentColor">
                <circle cx="12" cy="12" r="10"></circle>
            </svg>
            <span class="stat-value" id="online-nodes">0</span>
            <span class="stat-label">online</span>
        </div>
    </div>

    <!-- Chain Status Indicator (behind/syncing) -->
    <div id="chain-status-indicator" class="chain-status-indicator" style="display: none;" onclick="triggerManualSync()">
        <div class="chain-status-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
            </svg>
        </div>
        <span class="chain-status-text" id="chain-status-text">Chain behind</span>
        <span class="chain-status-action">Tap to sync</span>
    </div>

    <!-- Sync Progress Bar -->
    <div id="sync-progress-bar" class="sync-progress-bar" style="display: none;">
        <div class="sync-progress-content">
            <div class="sync-progress-icon">
                <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
                </svg>
            </div>
            <div class="sync-progress-info">
                <div class="sync-progress-text">
                    <span id="sync-status-text">Syncing blockchain...</span>
                    <span id="sync-progress-text" class="sync-progress-details"></span>
                </div>
                <div class="sync-progress-track">
                    <div class="sync-progress-fill" id="sync-progress-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Your Node Indicator -->
    <div class="your-node-indicator" id="your-node-indicator" style="display: none;">
        <div class="your-node-avatar" id="your-avatar">?</div>
        <div class="your-node-info">
            <h3 id="your-name">Your Node</h3>
            <p id="your-children">0 recruits</p>
        </div>
    </div>

    <!-- User Dashboard Panel -->
    <div id="dashboard-panel">
        <button class="dashboard-close">&times;</button>
        <div class="dashboard-content">
            <!-- Profile Header -->
            <div class="dashboard-profile">
                <div class="dashboard-avatar" id="dash-avatar">?</div>
                <h2 class="dashboard-name" id="dash-name">Your Name</h2>
                <div class="dashboard-subtitle">
                    <span id="dash-joined">Joined today</span>
                    <span class="node-id" id="dash-node-id">node_xxx</span>
                </div>
            </div>
            
            <!-- Stats Grid -->
            <div class="dashboard-stats">
                <div class="stat-card highlight" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(79, 70, 229, 0.2)); border-color: rgba(147, 51, 234, 0.4);">
                    <div class="stat-card-icon"></div>
                    <div class="stat-card-value" id="dash-karma">0</div>
                    <div class="stat-card-label">KARMA</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-card-icon"></div>
                    <div class="stat-card-value" id="dash-recruits">0</div>
                    <div class="stat-card-label">Direct Recruits</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-icon"></div>
                    <div class="stat-card-value" id="dash-network">0</div>
                    <div class="stat-card-label">Network Reach</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-icon"></div>
                    <div class="stat-card-value" id="dash-days">0</div>
                    <div class="stat-card-label">Days Active</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-icon"></div>
                    <div class="stat-card-value" id="dash-rank">#1</div>
                    <div class="stat-card-label">Network Rank</div>
                </div>
            </div>
            
            <!-- Network Connections -->
            <div class="dashboard-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title">Your Network</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div class="network-tree-mini" id="dash-network-tree">
                    <!-- Parent Node (if any) -->
                    <div class="network-node parent" id="dash-parent-node" style="display: none;">
                        <div class="network-node-avatar" id="dash-parent-avatar">?</div>
                        <div class="network-node-info">
                            <div class="network-node-name" id="dash-parent-name">Parent</div>
                            <div class="network-node-role">Your Recruiter</div>
                        </div>
                        <div class="network-node-status" id="dash-parent-status"></div>
                    </div>
                    
                    <!-- Self (You) -->
                    <div class="network-node self">
                        <div class="network-node-avatar" id="dash-self-avatar">?</div>
                        <div class="network-node-info">
                            <div class="network-node-name" id="dash-self-name">You</div>
                            <div class="network-node-role">That's you!</div>
                        </div>
                        <div class="network-node-status online"></div>
                    </div>
                    
                    <!-- Children preview -->
                    <div id="dash-children-container"></div>
                </div>
                
                <!-- Request Parent Connection Section -->
                <div id="request-parent-section" style="margin-top: 24px; padding: 20px; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 12px; display: none;">
                    <h3 style="margin: 0 0 12px 0; font-size: 1.1em; font-weight: 600; color: var(--text-primary);"> Connect to a Parent</h3>
                    <p style="margin: 0 0 16px 0; color: rgba(255, 255, 255, 0.7); font-size: 0.9em;">Request to become a child of another node (e.g., an institution) to receive tokens and credentials.</p>
                    <div style="display: flex; gap: 12px;">
                        <select id="parent-request-select" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: var(--text-primary); font-size: 0.95em; outline: none;">
                            <option value="">Select a node...</option>
                        </select>
                        <button id="request-parent-submit-btn" style="padding: 10px 20px; background: linear-gradient(135deg, #9333EA, #4F46E5); border: none; border-radius: 8px; color: white; font-size: 0.95em; font-weight: 600; cursor: pointer; transition: all 0.3s ease;" disabled>
                            Request
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Activity Timeline -->
            <div class="dashboard-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title">Recent Activity</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div class="activity-timeline" id="dash-activity">
                    <div class="activity-item">
                        <div class="activity-dot"></div>
                        <div class="activity-content">
                            <div class="activity-title">Joined Srishti Network</div>
                            <div class="activity-time" id="dash-join-time">Just now</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Blockchain Info -->
            <div class="dashboard-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title">Blockchain Info</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div class="blockchain-info">
                    <div class="blockchain-row">
                        <span class="blockchain-label">Chain Length</span>
                        <span class="blockchain-value" id="dash-chain-length">0 blocks</span>
                    </div>
                    <div class="blockchain-row">
                        <span class="blockchain-label">Your Block</span>
                        <span class="blockchain-value" id="dash-your-block">#0</span>
                    </div>
                    <div class="blockchain-row">
                        <span class="blockchain-label">Genesis Hash</span>
                        <span class="blockchain-value hash" id="dash-genesis-hash">-</span>
                    </div>
                    <div class="blockchain-row">
                        <span class="blockchain-label">Network Status</span>
                        <span class="blockchain-value" id="dash-network-status"> Online</span>
                    </div>
                    <div class="blockchain-row" id="reset-chain-row" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: none;">
                        <button id="reset-chain-btn" style="width: 100%; padding: 10px; background: rgba(220, 38, 38, 0.2); border: 1px solid rgba(220, 38, 38, 0.4); border-radius: 8px; color: #fca5a5; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                             Reset Chain (Clear All Nodes)
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Your Role & Institution Status -->
            <div class="dashboard-section" id="dash-role-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title"> Your Role</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div id="dash-role-container">
                    <!-- Will be populated by JS -->
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                        <span class="role-badge user" id="dash-role-badge"> USER</span>
                    </div>
                    <button class="register-institution-btn" id="register-institution-btn">
                        <span></span>
                        <span>Register as Institution</span>
                    </button>
                </div>
            </div>
            
            <!-- Pending Parent Requests (when you are the parent/institution) -->
            <div class="dashboard-section admin-section" id="dash-parent-requests-section" style="display: none;">
                <div class="admin-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span></span>
                        <span>Connection Requests</span>
                    </div>
                    <button onclick="updateParentRequests()" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; padding: 4px 10px; color: #fff; font-size: 0.75em; cursor: pointer;"> Refresh</button>
                </div>
                <div id="dash-parent-requests-list">
                    <div class="dashboard-empty" style="padding: 24px;">
                        <div class="dashboard-empty-icon"></div>
                        <div class="dashboard-empty-title">No pending requests</div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Connection requests from other nodes will appear here</div>
                    </div>
                </div>
            </div>
            
            <!-- Admin Panel (Only visible for ROOT/GOVERNANCE_ADMIN) -->
            <div class="dashboard-section admin-section" id="dash-admin-section" style="display: none;">
                <div class="admin-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span></span>
                        <span>Admin Panel</span>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button onclick="forceRebuildState()" style="background: rgba(255,165,0,0.2); border: 1px solid rgba(255,165,0,0.4); border-radius: 6px; padding: 4px 10px; color: #ffa500; font-size: 0.75em; cursor: pointer;"> Force Sync</button>
                        <button onclick="updateAdminSection()" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; padding: 4px 10px; color: #fff; font-size: 0.75em; cursor: pointer;"> Refresh</button>
                    </div>
                </div>
                <div id="dash-pending-institutions">
                    <div style="color: rgba(255,255,255,0.5); font-size: 0.85em; text-align: center; padding: 16px;">
                        No pending institution requests
                    </div>
                </div>
            </div>
            
            <!-- Soulbound Tokens (Credentials) -->
            <div class="dashboard-section" id="dash-soulbound-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title"> Soulbound Tokens</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div class="soulbound-grid" id="dash-soulbound-list">
                    <div class="dashboard-empty" style="padding: 24px;">
                        <div class="dashboard-empty-icon"></div>
                        <div class="dashboard-empty-title">No credentials yet</div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Non-transferable tokens will appear here</div>
                    </div>
                </div>
            </div>
            
            <!-- Governance Proposals -->
            <div class="dashboard-section" id="dash-proposals-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title"> Active Proposals</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div class="proposals-list" id="dash-proposals-list">
                    <div class="dashboard-empty" style="padding: 24px;">
                        <div class="dashboard-empty-icon"></div>
                        <div class="dashboard-empty-title">No active proposals</div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Governance proposals will appear here</div>
                    </div>
                </div>
            </div>
            
            <!-- Social Recovery / Guardians -->
            <div class="dashboard-section" id="dash-recovery-section">
                <div class="dashboard-section-header">
                    <span class="dashboard-section-title"> Social Recovery</span>
                    <div class="dashboard-section-line"></div>
                </div>
                <div id="dash-guardians-container">
                    <button class="setup-recovery-btn" id="setup-recovery-btn">
                        <span></span>
                        <span>Set Up Guardian Recovery</span>
                    </button>
                </div>
            </div>
            
            <!-- Actions -->
            <div class="dashboard-actions">
                <button class="dashboard-btn secondary" id="dash-share-btn">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                        <polyline points="16 6 12 2 8 6"></polyline>
                        <line x1="12" y1="2" x2="12" y2="15"></line>
                    </svg>
                    Share Invite
                </button>
                <button class="dashboard-btn primary" id="dash-qr-btn">
                    <svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="5" height="5"></rect>
                        <rect x="16" y="3" width="5" height="5"></rect>
                        <rect x="3" y="16" width="5" height="5"></rect>
                    </svg>
                    Show QR
                </button>
            </div>
        </div>
    </div>

    <!-- Floating Action Buttons -->
    <div class="fab-container">
        <button class="fab" id="dashboard-fab" title="Your Dashboard">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
        </button>
        <button class="fab" id="scan-fab" title="Scan QR Code">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
        </button>
        <button class="fab primary" id="qr-fab" title="Show Your QR">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="5" height="5"></rect>
                <rect x="16" y="3" width="5" height="5"></rect>
                <rect x="3" y="16" width="5" height="5"></rect>
                <path d="M21 16h-3a2 2 0 0 0-2 2v3"></path>
                <path d="M21 21v.01"></path>
                <path d="M12 7v3a2 2 0 0 1-2 2H7"></path>
                <path d="M3 12h.01"></path>
                <path d="M12 3h.01"></path>
                <path d="M12 16v.01"></path>
                <path d="M16 12h1"></path>
                <path d="M21 12v.01"></path>
                <path d="M12 21v-1"></path>
            </svg>
        </button>
    </div>

    <script>
        // ============================================
        // Simplex Noise Implementation
        // ============================================
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                for (let i = 0; i < 256; i++) {
                    this.p[i] = i;
                }
                
                let n, q;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 16807) % 2147483647;
                    n = seed % (i + 1);
                    q = this.p[i];
                    this.p[i] = this.p[n];
                    this.p[n] = q;
                }
                
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
                
                this.grad3 = new Float32Array([
                    1,1,0, -1,1,0, 1,-1,0, -1,-1,0,
                    1,0,1, -1,0,1, 1,0,-1, -1,0,-1,
                    0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1
                ]);
                
                this.F3 = 1.0 / 3.0;
                this.G3 = 1.0 / 6.0;
            }
            
            noise3D(x, y, z) {
                const { perm, permMod12, grad3, F3, G3 } = this;
                let n0, n1, n2, n3;
                
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                const z0 = z - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;
                
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                
                let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                if (t0 < 0) n0 = 0.0;
                else {
                    const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
                    t0 *= t0;
                    n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0+1] * y0 + grad3[gi0+2] * z0);
                }
                
                let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                if (t1 < 0) n1 = 0.0;
                else {
                    const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
                    t1 *= t1;
                    n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1+1] * y1 + grad3[gi1+2] * z1);
                }
                
                let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                if (t2 < 0) n2 = 0.0;
                else {
                    const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
                    t2 *= t2;
                    n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2+1] * y2 + grad3[gi2+2] * z2);
                }
                
                let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                if (t3 < 0) n3 = 0.0;
                else {
                    const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
                    t3 *= t3;
                    n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3+1] * y3 + grad3[gi3+2] * z3);
                }
                
                return 32.0 * (n0 + n1 + n2 + n3);
            }
        }
        
        const noise = new SimplexNoise(Math.random() * 10000);
        let noiseTime = 0;

        // ============================================
        // Application State
        // ============================================
        let currentUser = null;
        let nodesData = {};
        let nodeMeshes = [];
        let nodeDataMap = new Map();
        let unsubscribeNodes = null;

        // ============================================
        // Three.js Setup
        // ============================================
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 800);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x050510);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.03;
        controls.rotateSpeed = 0.2;
        controls.zoomSpeed = 0.4;
        controls.panSpeed = 0.3;
        controls.minDistance = 150;
        controls.maxDistance = 2000;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xFFD700, 0.8, 2000);
        pointLight1.position.set(500, 500, 500);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x4444ff, 0.4, 2000);
        pointLight2.position.set(-500, -500, 500);
        scene.add(pointLight2);

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1500;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 4000;
            starPositions[i + 1] = (Math.random() - 0.5) * 4000;
            starPositions[i + 2] = (Math.random() - 0.5) * 4000;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0x333344, size: 2, transparent: true, opacity: 0.6 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Main group for nodes
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Hover label
        let hoverLabel = null;
        
        function createLabelSprite(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = '600 34px Outfit, sans-serif';
            const textWidth = context.measureText(text).width;
            
            const padding = 36;
            const rectWidth = Math.min(textWidth + padding * 2, canvas.width - 20);
            const rectHeight = 56;
            const rectX = (canvas.width - rectWidth) / 2;
            const rectY = (canvas.height - rectHeight) / 2;
            
            // Glassmorphic background
            context.fillStyle = 'rgba(255, 255, 255, 0.12)';
            context.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            context.lineWidth = 1.5;
            
            const radius = 28;
            context.beginPath();
            context.moveTo(rectX + radius, rectY);
            context.lineTo(rectX + rectWidth - radius, rectY);
            context.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
            context.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
            context.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
            context.lineTo(rectX + radius, rectY + rectHeight);
            context.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
            context.lineTo(rectX, rectY + radius);
            context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Top highlight
            context.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(rectX + radius, rectY + 1);
            context.lineTo(rectX + rectWidth - radius, rectY + 1);
            context.stroke();
            
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                depthTest: false
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(120, 30, 1);
            sprite.visible = false;
            
            return sprite;
        }
        
        function updateLabelText(sprite, text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = '600 34px Outfit, sans-serif';
            const textWidth = context.measureText(text).width;
            
            const padding = 36;
            const rectWidth = Math.min(textWidth + padding * 2, canvas.width - 20);
            const rectHeight = 56;
            const rectX = (canvas.width - rectWidth) / 2;
            const rectY = (canvas.height - rectHeight) / 2;
            
            // Glassmorphic background
            context.fillStyle = 'rgba(255, 255, 255, 0.12)';
            context.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            context.lineWidth = 1.5;
            
            const radius = 28;
            context.beginPath();
            context.moveTo(rectX + radius, rectY);
            context.lineTo(rectX + rectWidth - radius, rectY);
            context.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
            context.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
            context.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
            context.lineTo(rectX + radius, rectY + rectHeight);
            context.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
            context.lineTo(rectX, rectY + radius);
            context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Top highlight
            context.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(rectX + radius, rectY + 1);
            context.lineTo(rectX + rectWidth - radius, rectY + 1);
            context.stroke();
            
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            sprite.material.map.dispose();
            sprite.material.map = new THREE.CanvasTexture(canvas);
            sprite.material.map.needsUpdate = true;
        }
        
        hoverLabel = createLabelSprite('');
        scene.add(hoverLabel);

        // Link objects storage
        let linkObjects = [];
        
        // Track last hierarchy signature to avoid unnecessary rebuilds
        let lastHierarchySignature = null;

        // ============================================
        // Visualization Functions
        // ============================================
        
        /**
         * Create a signature of the hierarchy structure (nodes and relationships)
         * This is used to detect if the structure actually changed
         */
        function getHierarchySignature(hierarchyData) {
            if (!hierarchyData) return null;
            
            // Flatten hierarchy to get all nodes
            function collectNodes(node, result = []) {
                if (node.isVirtualRoot) {
                    // For virtual root, process its children
                    if (node.children) {
                        node.children.forEach(child => collectNodes(child, result));
                    }
                } else {
                    // Collect node ID and its parent IDs
                    const nodeInfo = {
                        id: node.id,
                        parentIds: node.allParentIds || (node.parentId ? [node.parentId] : [])
                    };
                    result.push(nodeInfo);
                    
                    // Process children
                    if (node.children) {
                        node.children.forEach(child => collectNodes(child, result));
                    }
                }
                return result;
            }
            
            const nodes = collectNodes(hierarchyData);
            
            // Sort nodes by ID for consistent signatures
            nodes.sort((a, b) => a.id.localeCompare(b.id));
            
            // Create signature string: nodeIds sorted, and parent relationships
            const nodeIds = nodes.map(n => n.id).join(',');
            const relationships = nodes
                .map(n => `${n.id}:${n.parentIds.sort().join('|')}`)
                .join(';');
            
            return `${nodeIds.length}:${nodeIds}|${relationships}`;
        }
        
        function buildVisualization(hierarchyData) {
            // Check if hierarchy structure actually changed
            const newSignature = getHierarchySignature(hierarchyData);
            if (newSignature === lastHierarchySignature) {
                console.log(` Hierarchy structure unchanged, skipping rebuild`);
                return; // No structural changes, don't rebuild
            }
            
            console.log(` buildVisualization called with:`, hierarchyData);
            lastHierarchySignature = newSignature;
            
            // Clear existing
            while (mainGroup.children.length > 0) {
                mainGroup.remove(mainGroup.children[0]);
            }
            nodeMeshes = [];
            nodeDataMap.clear();
            linkObjects = [];
            
            if (!hierarchyData) {
                console.log(` No hierarchy data, returning`);
                return;
            }
            
            // If hierarchy has virtual root, flatten it by promoting its children to root level
            let actualRoot = hierarchyData;
            if (hierarchyData.isVirtualRoot && hierarchyData.children) {
                // If there's only one child of virtual root, use it as root
                // If multiple, we still need to create a tree structure
                if (hierarchyData.children.length === 1) {
                    actualRoot = hierarchyData.children[0];
                } else {
                    // Multiple roots - keep virtual root but we'll handle it in visualization
                    actualRoot = hierarchyData;
                }
            }
            
            const root = d3.hierarchy(actualRoot);
            let nodes = root.descendants();
            let links = root.links();
            
            // Filter out virtual root node from visualization if present
            const nodesBeforeFilter = nodes.length;
            nodes = nodes.filter(d => !d.data.isVirtualRoot);
            
            // Remove duplicate nodes by ID (keep first occurrence)
            const seenNodeIds = new Set();
            const uniqueNodes = [];
            nodes.forEach(node => {
                const nodeId = node.data.id;
                if (!seenNodeIds.has(nodeId)) {
                    seenNodeIds.add(nodeId);
                    uniqueNodes.push(node);
                } else {
                    console.warn(` Duplicate node detected in visualization: ${nodeId.substring(0, 12)} (${node.data.name}), skipping duplicate`);
                }
            });
            nodes = uniqueNodes;
            
            if (nodesBeforeFilter - nodes.length > 0) {
                console.log(` Removed ${nodesBeforeFilter - nodes.length} duplicate nodes from visualization`);
            }
            
            // Filter links to exclude those connecting to/from virtual root
            // Also ensure both source and target exist in filtered nodes
            const nodeIds = new Set(nodes.map(n => n.data.id));
            const filteredLinks = links.filter(link => {
                const sourceIsVirtual = link.source.data.isVirtualRoot;
                const targetIsVirtual = link.target.data.isVirtualRoot;
                const sourceExists = nodeIds.has(link.source.data.id);
                const targetExists = nodeIds.has(link.target.data.id);
                return !sourceIsVirtual && !targetIsVirtual && sourceExists && targetExists;
            });
            
            console.log(` Creating ${nodes.length} spheres, ${filteredLinks.length} links (filtered ${nodesBeforeFilter - nodes.length} virtual root nodes)`);
            
            // Layout (using the root with virtual root, but we'll only visualize filtered nodes)
            const treeLayout = d3.tree().size([2 * Math.PI, 500]);
            treeLayout(root);
            
            // Recalculate depths for filtered nodes (since we removed virtual root)
            // Find the minimum depth in filtered nodes to adjust all depths
            const minDepth = nodes.length > 0 ? Math.min(...nodes.map(n => n.depth)) : 0;
            
            // Position nodes
            nodes.forEach((d, i) => {
                const angle = d.x;
                const radius = d.y * 1.2;
                // Adjust depth: if virtual root was removed, reduce depth by 1
                const adjustedDepth = d.depth - minDepth;
                const height = (adjustedDepth - (root.height - minDepth) / 2) * 120;
                
                d.x3d = radius * Math.cos(angle);
                d.y3d = height;
                d.z3d = radius * Math.sin(angle);
                
                d.x = d.x3d;
                d.y = d.y3d;
                d.z = d.z3d;
                
                d.baseX = d.x;
                d.baseY = d.y;
                d.baseZ = d.z;
                d.noiseOffsetX = i * 100;
                d.noiseOffsetY = i * 100 + 1000;
                d.noiseOffsetZ = i * 100 + 2000;
                d.orbitRadius = d.children ? 15 : 25 + Math.random() * 15;
                d.orbitSpeed = 0.2 + Math.random() * 0.3;
            });
            
            // Create links (use filtered links)
            const linkMaterial = new THREE.LineBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.3
            });
            
            // Track created links to avoid duplicates (for multiple parents)
            const linkSet = new Set();
            const nodeIdToHierarchyNode = new Map();
            nodes.forEach(node => {
                nodeIdToHierarchyNode.set(node.data.id, node);
            });
            
            // First, create links from D3 tree (covers first parent for each node)
            filteredLinks.forEach(link => {
                const linkKey = `${link.source.data.id}-${link.target.data.id}`;
                if (!linkSet.has(linkKey)) {
                    linkSet.add(linkKey);
                    
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    const line = new THREE.Line(geometry, linkMaterial.clone());
                    mainGroup.add(line);
                    linkObjects.push({ line, source: link.source, target: link.target });
                }
            });
            
            // Now, add links for ALL other parents (supporting multiple parents)
            nodes.forEach(node => {
                const nodeData = node.data;
                const allParentIds = nodeData.allParentIds || [];
                
                // Create links to all parents (child -> parent)
                allParentIds.forEach(parentId => {
                    const parentNode = nodeIdToHierarchyNode.get(parentId);
                    if (parentNode) {
                        // Link from child (this node) to parent
                        const linkKey = `${node.data.id}-${parentId}`;
                        if (!linkSet.has(linkKey)) {
                            linkSet.add(linkKey);
                            
                            const geometry = new THREE.BufferGeometry();
                            const positions = new Float32Array(6);
                            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                            
                            const line = new THREE.Line(geometry, linkMaterial.clone());
                            mainGroup.add(line);
                            // Note: source is child (this node), target is parent
                            linkObjects.push({ line, source: node, target: parentNode });
                        }
                    }
                });
            });
            
            // Create node meshes
            // Scale sphere size based on number of nodes to prevent overlap
            const nodeCount = nodes.length;
            const scaleFactor = Math.max(0.4, Math.min(1.0, 50 / nodeCount)); // Scale down when more than 50 nodes
            
            nodes.forEach(d => {
                const nodeInfo = d.data;
                const isCurrentUser = currentUser && nodeInfo.id === currentUser.id;
                const baseRadius = isCurrentUser ? 12 : 8;
                const sphereRadius = baseRadius * scaleFactor;
                const geometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
                
                // Calculate glow
                const glow = window.SrishtiGlow ? window.SrishtiGlow.calculateGlow(nodeInfo) : { intensity: 0.2, color: { r: 60, g: 60, b: 80 } };
                const color = window.SrishtiGlow ? window.SrishtiGlow.rgbToHex(glow.color) : 0x3c3c50;
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: glow.emissive || 0.2,
                    shininess: 80,
                    transparent: true,
                    opacity: 0.95
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(d.x3d, d.y3d, d.z3d);
                mesh.userData = { 
                    nodeData: nodeInfo, 
                    hierarchyNode: d,
                    isCurrentUser: isCurrentUser,
                    glow: glow
                };
                
                d.mesh = mesh;
                mainGroup.add(mesh);
                nodeMeshes.push(mesh);
                nodeDataMap.set(mesh, d);
                
                // Add corona for high-glow nodes
                if (glow.intensity > 0.6) {
                    const baseCoronaRadius = isCurrentUser ? 15 : 12;
                    const coronaRadius = baseCoronaRadius * scaleFactor;
                    const coronaGeometry = new THREE.SphereGeometry(coronaRadius, 16, 16);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.15
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    mesh.add(corona);
                }
            });
            
            // Store for animation
            window.srishtiNodes = nodes;
            window.srishtiLinks = linkObjects;
        }
        
        function updateNodeGlows() {
            if (!window.SrishtiGlow) return;
            
            nodeMeshes.forEach(mesh => {
                const nodeInfo = mesh.userData.nodeData;
                if (!nodeInfo) return;
                
                // Get fresh data from nodesData
                const freshData = nodesData[nodeInfo.id];
                if (freshData) {
                    const glow = window.SrishtiGlow.calculateGlow(freshData);
                    mesh.userData.glow = glow;
                    
                    const color = window.SrishtiGlow.rgbToHex(glow.color);
                    mesh.material.color.setHex(color);
                    mesh.material.emissive.setHex(color);
                    mesh.material.emissiveIntensity = glow.emissive;
                }
            });
        }
        
        // ============================================
        // Animation
        // ============================================
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredMesh = null;
        let animationTime = 0;
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onClick(event) {
            if (event.target.closest('.fab-container') || 
                event.target.closest('#qr-modal') || 
                event.target.closest('#node-modal') ||
                event.target.closest('#onboarding-modal') ||
                event.target.closest('#mint-token-modal')) {
                return;
            }
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const nodeInfo = mesh.userData.nodeData;
                if (nodeInfo) {
                    showNodeModal(nodeInfo);
                }
            }
        }
        
        // Touch event handler for mobile devices
        const touchMouse = new THREE.Vector2();
        let lastTouchTime = 0;
        const TOUCH_DELAY = 300; // Prevent double-tap
        
        function onTouchEnd(event) {
            const now = Date.now();
            if (now - lastTouchTime < TOUCH_DELAY) {
                return; // Ignore rapid touches
            }
            lastTouchTime = now;
            
            // Check if touch is on a button or interactive element first
            // Don't preventDefault for buttons so they can handle their own click events
            const target = event.target;
            const isButton = target.closest('button') || 
                            target.closest('.fab') ||
                            target.closest('.fab-container') || 
                            target.closest('#qr-modal') || 
                            target.closest('#node-modal') ||
                            target.closest('#onboarding-modal') ||
                            target.closest('#mint-token-modal') ||
                            target.closest('.onboarding-btn') ||
                            target.closest('.qr-btn') ||
                            target.closest('.your-node-indicator');
            
            // Only preventDefault if NOT touching a button (to avoid double-tap zoom on canvas)
            if (!isButton) {
                event.preventDefault();
            }
            
            if (isButton) {
                return; // Let buttons handle their own click/touch events
            }
            
            const touch = event.changedTouches[0];
            if (!touch) return;
            
            touchMouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            touchMouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(touchMouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const nodeInfo = mesh.userData.nodeData;
                if (nodeInfo) {
                    showNodeModal(nodeInfo);
                }
            }
        }
        
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        // Add touch support for mobile
        window.addEventListener('touchend', onTouchEnd, { passive: false });
        
        function animate() {
            requestAnimationFrame(animate);
            
            animationTime += 0.016;
            noiseTime += 0.002;
            
            // Animate nodes
            if (window.srishtiNodes) {
                window.srishtiNodes.forEach(d => {
                    if (!d.parent) {
                        d.x = 0;
                        d.y = 0;
                        d.z = 0;
                        if (d.mesh) d.mesh.position.set(0, 0, 0);
                        return;
                    }
                    
                    const t = noiseTime * d.orbitSpeed;
                    const noiseX = noise.noise3D(d.noiseOffsetX * 0.01, t, 0);
                    const noiseY = noise.noise3D(d.noiseOffsetY * 0.01, t, 0);
                    const noiseZ = noise.noise3D(d.noiseOffsetZ * 0.01, t, 0);
                    
                    const offsetX = noiseX * d.orbitRadius;
                    const offsetY = noiseY * d.orbitRadius;
                    const offsetZ = noiseZ * d.orbitRadius;
                    
                    const targetX = d.baseX + offsetX;
                    const targetY = d.baseY + offsetY;
                    const targetZ = d.baseZ + offsetZ;
                    
                    const smoothing = 0.03;
                    d.x += (targetX - d.x) * smoothing;
                    d.y += (targetY - d.y) * smoothing;
                    d.z += (targetZ - d.z) * smoothing;
                    
                    if (d.mesh) {
                        d.mesh.position.set(d.x, d.y, d.z);
                        
                        // Pulse effect for online nodes
                        const glow = d.mesh.userData.glow;
                        if (glow && glow.pulse) {
                            const pulse = Math.sin(animationTime * glow.pulseSpeed * 2) * 0.2 + 0.8;
                            d.mesh.material.emissiveIntensity = glow.emissive * pulse;
                        }
                    }
                });
            }
            
            // Update links
            if (window.srishtiLinks) {
                window.srishtiLinks.forEach(({ line, source, target }) => {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = source.x;
                    positions[1] = source.y;
                    positions[2] = source.z;
                    positions[3] = target.x;
                    positions[4] = target.y;
                    positions[5] = target.z;
                    line.geometry.attributes.position.needsUpdate = true;
                    
                    // Glow links between online nodes
                    const sourceOnline = source.data && source.data.isOnline;
                    const targetOnline = target.data && target.data.isOnline;
                    if (sourceOnline && targetOnline) {
                        line.material.opacity = 0.6;
                    } else if (sourceOnline || targetOnline) {
                        line.material.opacity = 0.4;
                    } else {
                        line.material.opacity = 0.2;
                    }
                });
            }
            
            // Hover detection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (hoveredMesh && (!intersects.length || intersects[0].object !== hoveredMesh)) {
                hoveredMesh.scale.set(1, 1, 1);
                hoveredMesh = null;
                hoverLabel.visible = false;
                document.body.style.cursor = 'default';
            }
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh !== hoveredMesh) {
                    hoveredMesh = mesh;
                    mesh.scale.set(1.2, 1.2, 1.2);
                    
                    const nodeData = mesh.userData.nodeData;
                    if (nodeData) {
                        updateLabelText(hoverLabel, nodeData.name || 'Unknown');
                        hoverLabel.visible = true;
                    }
                    document.body.style.cursor = 'pointer';
                }
                
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                hoverLabel.position.copy(worldPos);
                hoverLabel.position.y += 35;
            }
            
            stars.rotation.y += 0.0001;
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ============================================
        // Dashboard Functions
        // ============================================
        
        // KARMA balance update interval (when dashboard is open)
        let karmaUpdateInterval = null;
        
        function showDashboard() {
            if (!currentUser) {
                alert('Please join the network first to view your dashboard.');
                return;
            }
            
            const panel = document.getElementById('dashboard-panel');
            const content = panel.querySelector('.dashboard-content');
            
            // Show panel with loading state
            panel.classList.add('open');
            
            // Show brief loading overlay
            const existingLoader = panel.querySelector('.dashboard-loader-overlay');
            if (!existingLoader) {
                const loader = document.createElement('div');
                loader.className = 'dashboard-loader-overlay';
                loader.innerHTML = `
                    <div class="loading-spinner" style="width: 28px; height: 28px;"></div>
                    <span style="margin-top: 12px; color: rgba(255,255,255,0.6); font-size: 12px;">Loading dashboard...</span>
                `;
                loader.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(5, 5, 16, 0.95);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 10;
                    transition: opacity 0.3s ease;
                `;
                panel.appendChild(loader);
                
                // Fade out loader after data loads
                setTimeout(() => {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.remove(), 300);
                }, 400);
            }
            
            updateDashboard();
            
            // Start periodic KARMA balance updates (every 10 seconds)
            if (karmaUpdateInterval) {
                clearInterval(karmaUpdateInterval);
            }
            karmaUpdateInterval = setInterval(() => {
                if (document.getElementById('dashboard-panel').classList.contains('open')) {
                    // Only update KARMA balance (fast update)
                    const karmaElement = document.getElementById('dash-karma');
                    if (karmaElement && window.SrishtiApp && window.SrishtiApp.getMyKarmaBalance) {
                        const karmaBalance = window.SrishtiApp.getMyKarmaBalance();
                        karmaElement.textContent = Math.floor(karmaBalance).toLocaleString();
                    }
                } else {
                    // Dashboard closed, stop interval
                    if (karmaUpdateInterval) {
                        clearInterval(karmaUpdateInterval);
                        karmaUpdateInterval = null;
                    }
                }
            }, 10000); // Update every 10 seconds
        }
        
        function hideDashboard() {
            document.getElementById('dashboard-panel').classList.remove('open');
            
            // Stop KARMA update interval
            if (karmaUpdateInterval) {
                clearInterval(karmaUpdateInterval);
                karmaUpdateInterval = null;
            }
        }
        
        function updateDashboard() {
            if (!currentUser) return;
            
            const userData = nodesData[currentUser.id] || {};
            const nodes = Object.values(nodesData).filter(n => !n.isVirtualRoot);
            
            // Profile section
            document.getElementById('dash-avatar').textContent = (userData.name || currentUser.name || '?')[0].toUpperCase();
            document.getElementById('dash-name').textContent = userData.name || currentUser.name || 'Your Name';
            document.getElementById('dash-node-id').textContent = currentUser.id.substring(0, 12) + '...';
            
            // Calculate join date
            const joinDate = userData.createdAt ? new Date(userData.createdAt) : new Date();
            document.getElementById('dash-joined').textContent = formatJoinDate(joinDate);
            
            // Stats
            const directRecruits = userData.childCount || 0;
            const networkReach = calculateNetworkReach(currentUser.id);
            const daysActive = Math.max(1, Math.floor((Date.now() - joinDate.getTime()) / (1000 * 60 * 60 * 24)));
            const rank = calculateNetworkRank(currentUser.id);
            
            // Get KARMA balance
            let karmaBalance = 0;
            if (window.SrishtiApp && window.SrishtiApp.getMyKarmaBalance) {
                karmaBalance = window.SrishtiApp.getMyKarmaBalance();
            }
            
            document.getElementById('dash-karma').textContent = Math.floor(karmaBalance).toLocaleString();
            document.getElementById('dash-recruits').textContent = directRecruits;
            document.getElementById('dash-network').textContent = networkReach;
            document.getElementById('dash-days').textContent = daysActive;
            document.getElementById('dash-rank').textContent = '#' + rank;
            
            // Network tree - Self
            document.getElementById('dash-self-avatar').textContent = (userData.name || currentUser.name || '?')[0].toUpperCase();
            document.getElementById('dash-self-name').textContent = userData.name || currentUser.name || 'You';
            
            // Parent node(s) - Support multiple parents
            const parentNode = document.getElementById('dash-parent-node');
            const requestParentSection = document.getElementById('request-parent-section');
            const nodeMap = window.SrishtiApp?.chain?.buildNodeMap() || {};
            const currentNode = nodeMap[currentUser.id];
            const currentParentIds = Array.isArray(currentNode?.parentIds) 
                ? currentNode.parentIds 
                : (currentNode?.parentId ? [currentNode.parentId] : []);
            
            // Display parent(s) - show first parent in the single parent display, or show count if multiple
            if (currentParentIds.length > 0 && nodesData[currentParentIds[0]]) {
                const parent = nodesData[currentParentIds[0]];
                parentNode.style.display = 'flex';
                document.getElementById('dash-parent-avatar').textContent = (parent.name || '?')[0].toUpperCase();
                const parentNameDisplay = currentParentIds.length > 1 
                    ? `${parent.name || 'Unknown'} (+${currentParentIds.length - 1} more)`
                    : parent.name || 'Unknown';
                document.getElementById('dash-parent-name').textContent = parentNameDisplay;
                const parentStatus = document.getElementById('dash-parent-status');
                // Parent is online if they're the current user OR marked as online
                const parentIsCurrentUser = currentUser && parent.id === currentUser.id;
                const parentIsOnline = parentIsCurrentUser || parent.isOnline;
                parentStatus.className = 'network-node-status' + (parentIsOnline ? ' online' : '');
            } else {
                parentNode.style.display = 'none';
            }
            
            // Always show request section if there are available nodes to connect to
            // (Support multiple parents - allow adding more parents even if already has some)
            if (requestParentSection) {
                // Filter nodes to only show those that aren't already parents
                const availableNodes = nodes.filter(n => 
                    n.id !== currentUser.id && 
                    !currentParentIds.includes(n.id)
                );
                
                if (availableNodes.length > 0) {
                    requestParentSection.style.display = 'block';
                    
                    // Populate parent request dropdown
                    const parentSelect = document.getElementById('parent-request-select');
                    if (parentSelect) {
                        // Preserve the currently selected value before rebuilding
                        const previousSelection = parentSelect.value;
                        
                        parentSelect.innerHTML = '<option value="">Select a node...</option>';
                        availableNodes.forEach(node => {
                            const option = document.createElement('option');
                            option.value = node.id;
                            option.textContent = `${node.name || 'Unknown'} ${node.isInstitution ? '' : ''}`;
                            parentSelect.appendChild(option);
                        });
                        
                        // Restore previous selection if it's still a valid option
                        if (previousSelection && availableNodes.some(n => n.id === previousSelection)) {
                            parentSelect.value = previousSelection;
                        }
                        
                        parentSelect.onchange = () => {
                            const submitBtn = document.getElementById('request-parent-submit-btn');
                            if (submitBtn) {
                                submitBtn.disabled = !parentSelect.value;
                            }
                        };
                    }
                    
                    // Handler for submit button
                    const submitBtn = document.getElementById('request-parent-submit-btn');
                    if (submitBtn) {
                        // Remove any existing click handlers to avoid duplicates
                        submitBtn.replaceWith(submitBtn.cloneNode(true));
                        const newSubmitBtn = document.getElementById('request-parent-submit-btn');
                        
                        // Set initial disabled state based on current selection
                        newSubmitBtn.disabled = !parentSelect.value;
                        
                        newSubmitBtn.onclick = async () => {
                            const selectedParentId = parentSelect.value;
                            if (selectedParentId) {
                                await handleRequestParent(selectedParentId);
                                // Refresh dashboard after request
                                setTimeout(() => {
                                    if (window.updateDashboard) window.updateDashboard();
                                }, 500);
                            }
                        };
                    }
                } else {
                    // Hide section if no available nodes
                    requestParentSection.style.display = 'none';
                }
            }
            
            // Children nodes
            const childrenContainer = document.getElementById('dash-children-container');
            childrenContainer.innerHTML = '';
            const children = nodes.filter(n => n.parentId === currentUser.id);
            
            if (children.length > 0) {
                const maxShow = Math.min(children.length, 3);
                for (let i = 0; i < maxShow; i++) {
                    const child = children[i];
                    // Child is online if they're the current user OR marked as online
                    const childIsCurrentUser = currentUser && child.id === currentUser.id;
                    const childIsOnline = childIsCurrentUser || child.isOnline;
                    const childNode = document.createElement('div');
                    childNode.className = 'network-node child';
                    childNode.innerHTML = `
                        <div class="network-node-avatar">${(child.name || '?')[0].toUpperCase()}</div>
                        <div class="network-node-info">
                            <div class="network-node-name">${child.name || 'Unknown'}</div>
                            <div class="network-node-role">Your Recruit</div>
                        </div>
                        <div class="network-node-status${childIsOnline ? ' online' : ''}"></div>
                    `;
                    childrenContainer.appendChild(childNode);
                }
                
                if (children.length > 3) {
                    const moreNode = document.createElement('div');
                    moreNode.className = 'network-node child';
                    moreNode.style.justifyContent = 'center';
                    moreNode.style.color = 'rgba(255, 255, 255, 0.5)';
                    moreNode.style.fontSize = '0.85em';
                    moreNode.textContent = `+ ${children.length - 3} more recruits`;
                    childrenContainer.appendChild(moreNode);
                }
            }
            
            // Activity timeline
            updateActivityTimeline();
            
            // Blockchain info
            updateBlockchainInfo();
            
            // Role & Institution section
            updateRoleSection();
            
            // New sections: Soulbound Tokens, Proposals, Guardians, Parent Requests
            updateSoulboundTokens();
            updateProposals();
            updateGuardians();
            updateParentRequests();
        }
        
        // Update Parent Requests section
        function updateParentRequests() {
            if (!window.SrishtiApp || !currentUser) return;
            
            const container = document.getElementById('dash-parent-requests-list');
            const section = document.getElementById('dash-parent-requests-section');
            if (!container || !section) return;
            
            // Check if user is an institution (verified or pending) - always show section for institutions
            const isInstitution = window.SrishtiApp.isInstitution();
            const myRole = window.SrishtiApp.getMyRole();
            const institutions = window.SrishtiApp.getInstitutions();
            const isPendingInstitution = institutions.pending && institutions.pending[currentUser.id];
            
            const pendingRequests = window.SrishtiApp.getPendingParentRequests();
            const requestArray = Object.values(pendingRequests);
            
            console.log(` updateParentRequests: isInstitution=${isInstitution}, isPendingInstitution=${!!isPendingInstitution}, role=${myRole}, pendingRequests=${requestArray.length}`);
            
            // Show section for institutions (verified or pending), ROOT, or if there are pending requests
            const shouldShowSection = isInstitution || isPendingInstitution || myRole === 'ROOT' || myRole === 'INSTITUTION';
            
            if (requestArray.length === 0) {
                if (shouldShowSection) {
                    // Show empty state for institutions
                    section.style.display = 'block';
                    container.innerHTML = `
                        <div class="dashboard-empty" style="padding: 24px;">
                            <div class="dashboard-empty-icon"></div>
                            <div class="dashboard-empty-title">No pending requests</div>
                            <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Connection requests from other nodes will appear here</div>
                        </div>
                    `;
                } else {
                    section.style.display = 'none';
                }
                return;
            }
            
            section.style.display = 'block';
            
            container.innerHTML = requestArray.map(request => {
                const node = nodesData[request.nodeId] || {};
                const nodeName = node.name || 'Unknown';
                const isOnline = node.isOnline || false;
                
                return `
                    <div class="parent-request-item" style="padding: 16px; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 8px; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <div style="width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(135deg, #9333EA, #4F46E5); display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 1.1em;">
                                ${(nodeName || '?')[0].toUpperCase()}
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${escapeHtml(nodeName)}</div>
                                <div style="font-size: 0.85em; color: rgba(255, 255, 255, 0.6);">
                                    ${escapeHtml(request.nodeId.substring(0, 16) + '...')}
                                    <span style="margin-left: 8px; color: ${isOnline ? '#4ade80' : '#94a3b8'};">
                                        ${isOnline ? ' Online' : ' Offline'}
                                    </span>
                                </div>
                            </div>
                        </div>
                        ${request.reason ? `<div style="padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; margin-bottom: 12px; font-size: 0.9em; color: rgba(255, 255, 255, 0.8);">"${escapeHtml(request.reason)}"</div>` : ''}
                        <div style="display: flex; gap: 8px;">
                            <button onclick="approveParentRequest('${request.nodeId}')" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 6px; color: white; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;">
                                 Approve
                            </button>
                            <button onclick="rejectParentRequest('${request.nodeId}')" style="flex: 1; padding: 10px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 6px; color: #fca5a5; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;">
                                 Reject
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Handle approve parent request
        async function approveParentRequest(childNodeId) {
            if (!window.SrishtiApp || !currentUser) {
                alert('Please join the network first');
                return;
            }
            
            try {
                const reason = prompt('Optional reason for approval:');
                await window.SrishtiApp.approveParentConnection(childNodeId, reason || null);
                alert(' Parent connection approved!');
                updateParentRequests();
                updateDashboard(); // Refresh dashboard
            } catch (error) {
                console.error('Failed to approve parent connection:', error);
                alert(` Failed to approve: ${error.message}`);
            }
        }
        
        // Handle reject parent request
        async function rejectParentRequest(childNodeId) {
            if (!window.SrishtiApp || !currentUser) {
                alert('Please join the network first');
                return;
            }
            
            try {
                const reason = prompt('Optional reason for rejection:');
                await window.SrishtiApp.rejectParentConnection(childNodeId, reason || null);
                alert(' Parent connection rejected');
                updateParentRequests();
            } catch (error) {
                console.error('Failed to reject parent connection:', error);
                alert(` Failed to reject: ${error.message}`);
            }
        }
        
        // Update Soulbound Tokens section
        function updateSoulboundTokens() {
            if (!window.SrishtiApp?.chain || !currentUser) return;
            
            const container = document.getElementById('dash-soulbound-list');
            const tokens = window.SrishtiApp.chain.getSoulboundTokens(currentUser.id);
            
            if (tokens.length === 0) {
                container.innerHTML = `
                    <div class="dashboard-empty" style="padding: 24px;">
                        <div class="dashboard-empty-icon"></div>
                        <div class="dashboard-empty-title">No credentials yet</div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Non-transferable tokens will appear here</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = tokens.map(token => `
                <div class="soulbound-token">
                    <div class="soulbound-icon"></div>
                    <div class="soulbound-info">
                        <div class="soulbound-name">${escapeHtml(token.achievementId || 'Credential')}</div>
                        <div class="soulbound-issuer">Issued by ${shortenAddress(token.issuer)}</div>
                    </div>
                    <div class="soulbound-badge">${token.revocable ? 'Revocable' : 'Permanent'}</div>
                </div>
            `).join('');
        }
        
        // Update Governance Proposals section
        function updateProposals() {
            if (!window.SrishtiApp?.chain) return;
            
            const container = document.getElementById('dash-proposals-list');
            const proposals = window.SrishtiApp.chain.getActiveProposals();
            const proposalArray = Object.values(proposals);
            
            if (proposalArray.length === 0) {
                container.innerHTML = `
                    <div class="dashboard-empty" style="padding: 24px;">
                        <div class="dashboard-empty-icon"></div>
                        <div class="dashboard-empty-title">No active proposals</div>
                        <div style="color: rgba(255,255,255,0.4); font-size: 0.85em;">Governance proposals will appear here</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = proposalArray.slice(0, 3).map(proposal => `
                <div class="proposal-card">
                    <div class="proposal-header">
                        <span class="proposal-id">${escapeHtml(proposal.proposalId)}</span>
                        <span class="proposal-status ${proposal.status === 'ACTIVE' ? 'active' : 'ended'}">${proposal.status}</span>
                    </div>
                    <div class="proposal-description">${escapeHtml(proposal.description || 'No description')}</div>
                    <div class="proposal-meta">
                        <span> Quorum: ${proposal.quorumThreshold}</span>
                        <span> ${proposal.votingPeriodBlocks} blocks</span>
                    </div>
                </div>
            `).join('');
            
            if (proposalArray.length > 3) {
                container.innerHTML += `<div style="text-align: center; color: rgba(255,255,255,0.5); font-size: 0.85em; padding: 8px;">+ ${proposalArray.length - 3} more proposals</div>`;
            }
        }
        
        // Update Social Recovery / Guardians section
        function updateGuardians() {
            if (!window.SrishtiApp?.chain || !currentUser) return;
            
            const container = document.getElementById('dash-guardians-container');
            const accountState = window.SrishtiApp.chain.getAccountState(currentUser.id);
            
            if (!accountState || !accountState.guardians || accountState.guardians.length === 0) {
                container.innerHTML = `
                    <button class="setup-recovery-btn" id="setup-recovery-btn">
                        <span></span>
                        <span>Set Up Guardian Recovery</span>
                    </button>
                `;
                // Re-attach event listener
                document.getElementById('setup-recovery-btn')?.addEventListener('click', showSetupRecoveryModal);
                return;
            }
            
            const guardians = accountState.guardians;
            const threshold = accountState.recoveryThreshold;
            
            container.innerHTML = `
                <div class="guardians-container">
                    <div class="guardians-header">
                        <span class="guardians-threshold">Threshold: ${threshold} of ${guardians.length}</span>
                        <span class="guardians-count">${guardians.length} guardians</span>
                    </div>
                    <div class="guardians-list">
                        ${guardians.map((g, i) => `
                            <div class="guardian-item">
                                <div class="guardian-icon"></div>
                                <div class="guardian-address">${shortenAddress(g)}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        // Update Role & Institution section
        function updateRoleSection() {
            if (!window.SrishtiApp || !currentUser) return;
            
            const container = document.getElementById('dash-role-container');
            const badgeEl = document.getElementById('dash-role-badge');
            const adminSection = document.getElementById('dash-admin-section');
            
            const myRole = window.SrishtiApp.getMyRole();
            const isInstitution = window.SrishtiApp.isInstitution();
            const institutions = window.SrishtiApp.getInstitutions();
            const myInstitution = institutions.verified[currentUser.id];
            const myPending = institutions.pending[currentUser.id];
            
            // Update role badge
            let badgeClass = 'user';
            let badgeText = ' USER';
            
            if (myRole === 'ROOT') {
                badgeClass = 'root';
                badgeText = ' ROOT';
            } else if (myRole === 'GOVERNANCE_ADMIN') {
                badgeClass = 'root';
                badgeText = ' GOVERNANCE';
            } else if (isInstitution) {
                badgeClass = 'institution';
                badgeText = ' INSTITUTION';
            }
            
            // Build container HTML
            let html = `
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                    <span class="role-badge ${badgeClass}">${badgeText}</span>
                </div>
            `;
            
            if (isInstitution && myInstitution) {
                html += `
                    <div class="institution-info">
                        <div class="institution-name">${escapeHtml(myInstitution.name)}</div>
                        <div class="institution-category">${myInstitution.category}  Verified </div>
                    </div>
                    <button class="register-institution-btn" id="issue-token-btn" style="margin-top: 12px;">
                        <span></span>
                        <span>Issue Token</span>
                    </button>
                `;
            } else if (myPending) {
                html += `
                    <div class="institution-info" style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05)); border-color: rgba(251, 191, 36, 0.2);">
                        <div class="institution-name">${escapeHtml(myPending.name)}</div>
                        <div class="institution-category" style="color: rgba(251, 191, 36, 0.9);">${myPending.category}  Pending Verification </div>
                    </div>
                `;
            } else if (myRole !== 'ROOT' && myRole !== 'GOVERNANCE_ADMIN') {
                html += `
                    <button class="register-institution-btn" id="register-institution-btn">
                        <span></span>
                        <span>Register as Institution</span>
                    </button>
                `;
            }
            
            container.innerHTML = html;
            
            // Re-attach event listeners
            document.getElementById('register-institution-btn')?.addEventListener('click', showRegisterInstitutionModal);
            document.getElementById('issue-token-btn')?.addEventListener('click', showMintTokenModal);
            
            // Show/hide admin section
            if (myRole === 'ROOT' || myRole === 'GOVERNANCE_ADMIN') {
                adminSection.style.display = 'block';
                updateAdminSection();
            } else {
                adminSection.style.display = 'none';
            }
            
            // Show reset chain button only for ROOT users
            const resetChainRow = document.getElementById('reset-chain-row');
            if (resetChainRow) {
                resetChainRow.style.display = (myRole === 'ROOT') ? 'block' : 'none';
            }
        }
        
        // Update Admin Section (pending institutions)
        function updateAdminSection() {
            if (!window.SrishtiApp) return;
            
            const container = document.getElementById('dash-pending-institutions');
            const pending = window.SrishtiApp.getPendingInstitutions();
            const pendingList = Object.entries(pending).filter(([_, p]) => p.status === 'PENDING');
            
            if (pendingList.length === 0) {
                container.innerHTML = `
                    <div style="color: rgba(255,255,255,0.5); font-size: 0.85em; text-align: center; padding: 16px;">
                        No pending institution requests
                    </div>
                `;
                return;
            }
            
            container.innerHTML = pendingList.map(([nodeId, inst]) => `
                <div class="pending-institution" data-node-id="${nodeId}">
                    <div class="pending-header">
                        <span class="pending-name">${escapeHtml(inst.name)}</span>
                        <span class="pending-category">${inst.category}</span>
                    </div>
                    <div class="pending-id">${shortenAddress(nodeId)}</div>
                    <div class="pending-actions">
                        <button class="approve-btn" onclick="approveInstitution('${nodeId}')"> Approve</button>
                        <button class="reject-btn" onclick="rejectInstitution('${nodeId}')"> Reject</button>
                    </div>
                </div>
            `).join('');
            
            console.log(` Admin Panel updated with ${pendingList.length} pending requests`);
        }
        
        // Force rebuild chain state from blocks
        async function forceRebuildState() {
            if (!window.SrishtiApp || !window.SrishtiApp.chain) {
                alert('App not initialized');
                return;
            }
            
            try {
                console.log(' Force rebuilding chain state...');
                const chain = window.SrishtiApp.chain;
                
                // Reset state
                chain.state = {
                    activeProposals: {},
                    accountStates: {},
                    soulboundTokens: {},
                    institutions: {},
                    pendingInstitutions: {},
                    nodeRoles: {},
                    pendingParentRequests: {},
                    karmaBalances: {}
                };
                
                // Reprocess all blocks
                for (const block of chain.blocks) {
                    await chain.processTransactions(block);
                }
                
                console.log(' State rebuilt! pendingInstitutions:', chain.state.pendingInstitutions);
                console.log(' State rebuilt! nodeRoles:', chain.state.nodeRoles);
                
                // Refresh UI
                updateAdminSection();
                updateRoleSection();
                alert(' State rebuilt from ' + chain.blocks.length + ' blocks. Check console for details.');
            } catch (error) {
                console.error('Failed to rebuild state:', error);
                alert('Error: ' + error.message);
            }
        }
        
        // Approve institution
        async function approveInstitution(nodeId) {
            try {
                await window.SrishtiApp.verifyInstitution(nodeId, true, 'Approved by admin');
                updateRoleSection();
                alert('Institution approved successfully!');
            } catch (error) {
                console.error('Failed to approve:', error);
                alert('Failed to approve: ' + error.message);
            }
        }
        
        // Reject institution
        async function rejectInstitution(nodeId) {
            const reason = prompt('Reason for rejection (optional):');
            try {
                await window.SrishtiApp.verifyInstitution(nodeId, false, reason || 'Rejected by admin');
                updateRoleSection();
                alert('Institution rejected.');
            } catch (error) {
                console.error('Failed to reject:', error);
                alert('Failed to reject: ' + error.message);
            }
        }
        
        // Show Register Institution Modal
        function showRegisterInstitutionModal() {
            const categories = ['EDUCATION', 'CERTIFICATION', 'GOVERNMENT', 'EMPLOYER', 'HEALTHCARE', 'COMMUNITY'];
            
            const name = prompt('Institution Name:');
            if (!name) return;
            
            const category = prompt(`Category (${categories.join(', ')}):`);
            if (!category || !categories.includes(category.toUpperCase())) {
                alert(`Invalid category. Must be one of: ${categories.join(', ')}`);
                return;
            }
            
            const description = prompt('Description (optional):') || '';
            
            registerAsInstitution(name, category.toUpperCase(), description);
        }
        
        // Register as institution
        async function registerAsInstitution(name, category, description) {
            try {
                await window.SrishtiApp.registerInstitution({
                    name: name,
                    category: category,
                    description: description
                });
                updateRoleSection();
                alert('Registration submitted! Waiting for approval from network administrators.');
            } catch (error) {
                console.error('Failed to register:', error);
                alert('Failed to register: ' + error.message);
            }
        }
        
        // Show Mint Token Modal
        function showMintTokenModal() {
            if (!window.SrishtiApp || !window.SrishtiApp.isInstitution()) {
                alert('Only verified institutions can issue tokens.');
                return;
            }
            
            // Get all nodes in the network
            const nodes = window.SrishtiApp.getNodes();
            const recipientSelect = document.getElementById('mint-recipient');
            
            // Clear existing options except the first one
            recipientSelect.innerHTML = '<option value="">Select a recipient...</option>';
            
            // Add all nodes except self as recipients
            const currentUserId = window.SrishtiApp.nodeId;
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (nodeId !== currentUserId && !node.isVirtualRoot) {
                    const option = document.createElement('option');
                    option.value = nodeId;
                    option.textContent = `${node.name || 'Unknown'} (${shortenAddress(nodeId)})`;
                    recipientSelect.appendChild(option);
                }
            });
            
            if (recipientSelect.options.length === 1) {
                recipientSelect.innerHTML = '<option value="">No recipients available</option>';
                recipientSelect.disabled = true;
            } else {
                recipientSelect.disabled = false;
            }
            
            // Reset form
            document.getElementById('mint-token-form').reset();
            document.getElementById('mint-revocable').checked = true;
            
            // Show modal
            document.getElementById('mint-token-modal').classList.add('active');
        }
        
        // Hide Mint Token Modal
        function hideMintTokenModal() {
            document.getElementById('mint-token-modal').classList.remove('active');
        }
        
        // Handle Mint Token Form Submission
        async function handleMintTokenSubmit(event) {
            event.preventDefault();
            
            const recipient = document.getElementById('mint-recipient').value;
            const achievementId = document.getElementById('mint-achievement-id').value.trim();
            const title = document.getElementById('mint-title').value.trim();
            const description = document.getElementById('mint-description').value.trim();
            const revocable = document.getElementById('mint-revocable').checked;
            
            if (!recipient || !achievementId || !title) {
                alert('Please fill in all required fields.');
                return;
            }
            
            try {
                const submitBtn = document.querySelector('.mint-token-submit');
                submitBtn.disabled = true;
                submitBtn.textContent = 'Issuing...';
                
                await window.SrishtiApp.mintSoulboundToken(recipient, {
                    achievementId: achievementId,
                    title: title,
                    description: description,
                    revocable: revocable
                });
                
                hideMintTokenModal();
                updateSoulboundTokens(); // Update the recipient's view (if they're viewing)
                alert(`Token "${title}" successfully issued!`);
            } catch (error) {
                console.error('Failed to mint token:', error);
                alert('Failed to issue token: ' + error.message);
            } finally {
                const submitBtn = document.querySelector('.mint-token-submit');
                submitBtn.disabled = false;
                submitBtn.textContent = 'Issue Token';
            }
        }
        
        // Helper: Shorten address for display
        function shortenAddress(address) {
            if (!address || address.length < 12) return address || 'Unknown';
            return address.substring(0, 8) + '...' + address.substring(address.length - 6);
        }
        
        // Helper: Escape HTML to prevent XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Modal for setting up social recovery (placeholder)
        function showSetupRecoveryModal() {
            alert('Social Recovery Setup\n\nThis feature allows you to designate trusted guardians who can help recover your account.\n\nComing soon!');
        }
        
        function formatJoinDate(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) return 'Joined today';
            if (diffDays === 1) return 'Joined yesterday';
            if (diffDays < 7) return `Joined ${diffDays} days ago`;
            if (diffDays < 30) return `Joined ${Math.floor(diffDays / 7)} weeks ago`;
            return `Joined ${date.toLocaleDateString()}`;
        }
        
        function calculateNetworkReach(nodeId) {
            // Calculate total descendants recursively
            function countDescendants(id) {
                let count = 0;
                for (const node of Object.values(nodesData)) {
                    if (node.parentId === id && !node.isVirtualRoot) {
                        count += 1 + countDescendants(node.id);
                    }
                }
                return count;
            }
            return countDescendants(nodeId);
        }
        
        function calculateNetworkRank(nodeId) {
            // Rank by total network reach (descendants)
            const nodes = Object.values(nodesData).filter(n => !n.isVirtualRoot);
            const rankings = nodes.map(n => ({
                id: n.id,
                reach: calculateNetworkReach(n.id)
            }));
            rankings.sort((a, b) => b.reach - a.reach);
            
            const rank = rankings.findIndex(r => r.id === nodeId) + 1;
            return rank || nodes.length;
        }
        
        function updateActivityTimeline() {
            const timeline = document.getElementById('dash-activity');
            const events = [];
            
            // Add join event
            const userData = nodesData[currentUser.id] || {};
            if (userData.createdAt) {
                events.push({
                    icon: '',
                    title: 'Joined Srishti Network',
                    time: userData.createdAt
                });
            }
            
            // Add recruits as events
            const children = Object.values(nodesData).filter(n => n.parentId === currentUser.id && !n.isVirtualRoot);
            children.forEach(child => {
                events.push({
                    icon: '',
                    title: `Recruited ${child.name || 'a node'}`,
                    time: child.createdAt || Date.now()
                });
            });
            
            // Sort by time descending
            events.sort((a, b) => b.time - a.time);
            
            // Render timeline
            timeline.innerHTML = '';
            const maxEvents = Math.min(events.length, 5);
            
            if (maxEvents === 0) {
                timeline.innerHTML = `
                    <div class="activity-item">
                        <div class="activity-dot"></div>
                        <div class="activity-content">
                            <div class="activity-title">Welcome to Srishti!</div>
                            <div class="activity-time">Start recruiting to grow your network</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            for (let i = 0; i < maxEvents; i++) {
                const event = events[i];
                const item = document.createElement('div');
                item.className = 'activity-item';
                item.innerHTML = `
                    <div class="activity-dot">${event.icon}</div>
                    <div class="activity-content">
                        <div class="activity-title">${event.title}</div>
                        <div class="activity-time">${formatTimeAgo(event.time)}</div>
                    </div>
                `;
                timeline.appendChild(item);
            }
        }
        
        function formatTimeAgo(timestamp) {
            const diff = Date.now() - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes} min ago`;
            if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            if (days < 7) return `${days} day${days > 1 ? 's' : ''} ago`;
            return new Date(timestamp).toLocaleDateString();
        }
        
        function updateBlockchainInfo() {
            if (!window.SrishtiApp || !window.SrishtiApp.chain) return;
            
            const chain = window.SrishtiApp.chain;
            const chainLength = chain.getLength();
            
            document.getElementById('dash-chain-length').textContent = `${chainLength} block${chainLength !== 1 ? 's' : ''}`;
            
            // Find user's block
            const userBlockIndex = findUserBlockIndex(currentUser.id);
            document.getElementById('dash-your-block').textContent = userBlockIndex !== -1 ? `#${userBlockIndex}` : '-';
            
            // Genesis hash
            const genesis = chain.getBlock(0);
            if (genesis && genesis.hash) {
                document.getElementById('dash-genesis-hash').textContent = genesis.hash.substring(0, 16) + '...';
            }
            
            // Network status - check actual connection state
            const network = window.SrishtiApp?.network;
            const signalingConnected = network?.signaling?.isConnected?.() || false;
            // Use peerInfo for verified compatible peers, not raw WebSocket count
            const peerCount = network?.peerInfo?.size || 0;
            
            let networkStatusText;
            if (signalingConnected && peerCount > 0) {
                networkStatusText = ` Online (${peerCount} peer${peerCount !== 1 ? 's' : ''})`;
            } else if (signalingConnected) {
                networkStatusText = ' Connected (no peers)';
            } else if (network) {
                networkStatusText = ' Connecting...';
            } else {
                networkStatusText = ' Offline';
            }
            document.getElementById('dash-network-status').textContent = networkStatusText;
        }
        
        function findUserBlockIndex(nodeId) {
            if (!window.SrishtiApp || !window.SrishtiApp.chain) return -1;
            
            const chain = window.SrishtiApp.chain;
            for (let i = 0; i < chain.getLength(); i++) {
                const block = chain.getBlock(i);
                const events = block.getEvents();
                for (const event of events) {
                    if (event.type === 'NODE_JOIN' && event.nodeId === nodeId) {
                        return i;
                    }
                }
            }
            return -1;
        }
        
        // ============================================
        // UI Functions
        // ============================================
        
        function showOnboardingModal(parentId = null) {
            const modal = document.getElementById('onboarding-modal');
            const joinInfo = document.getElementById('join-parent-info');
            const parentDisplay = document.getElementById('parent-name-display');
            const selectParentSection = document.getElementById('select-parent-section');
            const parentSelect = document.getElementById('parent-select');
            const joinBtn = document.getElementById('join-btn');
            const nameInput = document.getElementById('user-name');
            const recoverBtn = document.getElementById('recover-node-btn');
            
            // Get existing nodes for parent selection
            const existingNodes = Object.values(nodesData).filter(n => !n.isVirtualRoot);
            const hasExistingNodes = existingNodes.length > 0;
            
            // Check if joining under a specific parent (from QR code)
            if (parentId && nodesData[parentId]) {
                joinInfo.style.display = 'block';
                parentDisplay.textContent = nodesData[parentId].name || 'A node';
                selectParentSection.style.display = 'none';
                modal.dataset.parentId = parentId;
            } else if (hasExistingNodes) {
                // No QR parent but there are nodes - show parent selection
                joinInfo.style.display = 'none';
                selectParentSection.style.display = 'block';
                
                // Populate parent select dropdown
                parentSelect.innerHTML = '<option value="">Select a node to join under...</option>';
                
                // Sort nodes: ROOT first, then by name
                const sortedNodes = [...existingNodes].sort((a, b) => {
                    const roleA = window.SrishtiApp?.chain?.state?.nodeRoles?.[a.id] || 'USER';
                    const roleB = window.SrishtiApp?.chain?.state?.nodeRoles?.[b.id] || 'USER';
                    if (roleA === 'ROOT' && roleB !== 'ROOT') return -1;
                    if (roleB === 'ROOT' && roleA !== 'ROOT') return 1;
                    return (a.name || '').localeCompare(b.name || '');
                });
                
                sortedNodes.forEach(node => {
                    const role = window.SrishtiApp?.chain?.state?.nodeRoles?.[node.id] || 'USER';
                    const roleLabel = role === 'ROOT' ? '  (Root)' : role === 'INSTITUTION' ? ' ' : '';
                    const option = document.createElement('option');
                    option.value = node.id;
                    option.textContent = `${node.name || 'Unknown'}${roleLabel}`;
                    parentSelect.appendChild(option);
                });
                
                // Auto-select root node if exists
                const rootNode = sortedNodes.find(n => 
                    window.SrishtiApp?.chain?.state?.nodeRoles?.[n.id] === 'ROOT'
                );
                if (rootNode) {
                    parentSelect.value = rootNode.id;
                    modal.dataset.parentId = rootNode.id;
                } else {
                    modal.dataset.parentId = '';
                }
                
                // Update parentId when selection changes
                parentSelect.onchange = () => {
                    modal.dataset.parentId = parentSelect.value;
                    updateJoinButtonState();
                };
            } else {
                // No nodes at all - this will be the first/genesis node
                joinInfo.style.display = 'none';
                selectParentSection.style.display = 'none';
                modal.dataset.parentId = '';
            }
            
            // Enable/disable button based on input AND parent selection
            nameInput.value = '';
            
            const updateJoinButtonState = () => {
                const nameValid = nameInput.value.trim().length >= 2;
                const parentValid = !hasExistingNodes || modal.dataset.parentId;
                joinBtn.disabled = !nameValid || !parentValid;
            };
            
            updateJoinButtonState();
            
            nameInput.oninput = updateJoinButtonState;
            
            joinBtn.onclick = async () => {
                const name = nameInput.value.trim();
                if (name.length < 2) return;
                
                // Validate parent selection if nodes exist
                if (hasExistingNodes && !modal.dataset.parentId) {
                    alert('Please select a node to join under, or scan a QR code.');
                    return;
                }
                
                joinBtn.disabled = true;
                joinBtn.innerHTML = `
                    <span class="btn-spinner" style="
                        display: inline-block;
                        width: 16px;
                        height: 16px;
                        border: 2px solid rgba(0, 0, 0, 0.2);
                        border-top-color: rgba(0, 0, 0, 0.8);
                        border-radius: 50%;
                        animation: spin 0.8s linear infinite;
                        margin-right: 8px;
                        vertical-align: middle;
                    "></span>
                    <span>Connecting to network...</span>
                `;
                
                await joinNetwork(name, modal.dataset.parentId || null);
            };
            
            // Recovery button handler
            recoverBtn.onclick = () => {
                if (window.SrishtiRecovery) {
                    window.SrishtiRecovery.init();
                    window.SrishtiRecovery.showRecoverInputModal(handleRecoveredNode);
                }
            };
            
            modal.classList.add('active');
            setTimeout(() => nameInput.focus(), 100);
        }
        
        async function handleRecoveredNode(recoveryData) {
            const { phrase, name } = recoveryData;
            
            try {
                console.log(' Starting recovery process...');
                
                // Show loading message
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'recovery-loading';
                loadingMsg.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    color: #fff;
                `;
                loadingMsg.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 20px;"> Recovering Node...</div>
                        <div style="font-size: 14px; color: #888;">Syncing with network to find your node...</div>
                    </div>
                `;
                document.body.appendChild(loadingMsg);
                
                // Step 1: Initialize network and sync with peers to get full chain
                console.log(' Step 1: Initializing network and syncing...');
                
                // Create a temporary node ID for network initialization
                // We'll use a temporary key pair just to connect to the network
                const tempKeyPair = await window.SrishtiKeys.generateKeyPair();
                const tempNodeId = await window.SrishtiKeys.generateNodeId(tempKeyPair.publicKey);
                
                // Initialize network with temporary identity (we'll replace it after finding the real node)
                if (!window.SrishtiApp.network) {
                    const signalingUrl = window.SRISHTI_SIGNALING_URL || 
                                       (window.location.protocol === 'https:' 
                                           ? 'wss://srishti-signaling.fly.dev' 
                                           : 'ws://localhost:8080');
                    
                    window.SrishtiApp.network = new window.SrishtiNetwork({
                        nodeId: tempNodeId,
                        publicKey: tempKeyPair.publicKey,
                        chain: window.SrishtiApp.chain,
                        storage: window.SrishtiApp.storage,
                        signalingServerUrl: signalingUrl,
                        onChainUpdate: () => {
                            window.SrishtiApp.adapter.onChainUpdate();
                        },
                        onPresenceUpdate: (nodeId, presenceData) => {
                            window.SrishtiApp.adapter.updatePresence(nodeId, presenceData);
                        }
                    });
                    
                    await window.SrishtiApp.network.init();
                    console.log(' Network initialized for recovery');
                }
                
                // Wait for sync with peers - smarter waiting based on actual node data
                console.log(' Waiting for network sync...');
                let syncAttempts = 0;
                const maxSyncAttempts = 40; // 20 seconds max wait (increased)
                let lastNodeCount = 0;
                let stableCount = 0;
                
                // Update loading message
                const updateRecoveryStatus = (msg) => {
                    const loadingText = loadingMsg.querySelector('p');
                    if (loadingText) loadingText.textContent = msg;
                };
                
                while (syncAttempts < maxSyncAttempts) {
                    // Use peerInfo.size for verified compatible peers
                    const connectedPeers = window.SrishtiApp.network.peerInfo?.size || 0;
                    const chainLength = window.SrishtiApp.chain.getLength();
                    const nodeMap = window.SrishtiApp.chain.buildNodeMap();
                    const nodeCount = Object.keys(nodeMap).length;
                    
                    // Check if chain is stable (node count not changing)
                    if (nodeCount === lastNodeCount && nodeCount > 0) {
                        stableCount++;
                    } else {
                        stableCount = 0;
                        lastNodeCount = nodeCount;
                    }
                    
                    // Update sync status in global var for recovery modal
                    window._guestSyncStatus = {
                        complete: stableCount >= 5,
                        nodeCount: nodeCount,
                        chainLength: chainLength,
                        connectedPeers: connectedPeers
                    };
                    
                    const statusMsg = connectedPeers > 0 
                        ? `Syncing... ${nodeCount} nodes, ${connectedPeers} peer${connectedPeers > 1 ? 's' : ''}`
                        : `Loading... ${nodeCount} nodes`;
                    
                    console.log(` Sync ${syncAttempts + 1}/${maxSyncAttempts}: ${statusMsg}`);
                    updateRecoveryStatus(statusMsg);
                    
                    // Success conditions:
                    // 1. We have nodes and chain has been stable for a while
                    // 2. We have peers, nodes, and chain length indicates we're synced
                    if ((nodeCount > 0 && stableCount >= 5) || 
                        (connectedPeers > 0 && nodeCount > 0 && chainLength > 1 && stableCount >= 3)) {
                        console.log(' Network sync complete');
                        updateRecoveryStatus(`Synced ${nodeCount} nodes!`);
                        break;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    syncAttempts++;
                }
                
                // Final node count check
                const finalNodeMap = window.SrishtiApp.chain.buildNodeMap();
                const finalNodeCount = Object.keys(finalNodeMap).length;
                console.log(` Final state: ${finalNodeCount} nodes in chain`);
                
                // Step 2: Search the synced chain for a node with matching phrase hash
                console.log(' Step 2: Searching chain for recovery phrase...');
                const phraseHash = await window.SrishtiRecovery.hashPhrase(phrase);
                const nodes = window.SrishtiApp.chain.buildNodeMap();
                
                console.log(` Searching ${Object.keys(nodes).length} nodes in chain...`);
                
                let foundNode = null;
                for (const [nodeId, node] of Object.entries(nodes)) {
                    if (node.recoveryPhraseHash === phraseHash) {
                        foundNode = { id: nodeId, ...node };
                        console.log(` Found matching node: ${foundNode.name} (${nodeId})`);
                        break;
                    }
                }
                
                // Remove loading message
                loadingMsg.remove();
                
                if (!foundNode) {
                    // Recovery phrase doesn't match any known node
                    const syncStatus = window._guestSyncStatus || {};
                    const searchedNodes = Object.keys(nodes).length;
                    const connectedPeers = syncStatus.connectedPeers || 0;
                    
                    console.error(` Recovery phrase not found (searched ${searchedNodes} nodes)`);
                    
                    // Provide more helpful error message based on sync state
                    let errorMsg = `Recovery phrase not found.\n\n`;
                    
                    if (searchedNodes === 0) {
                        errorMsg += ` No nodes have been synced yet!\n\n`;
                        errorMsg += `Please wait for the network to sync:\n`;
                        errorMsg += ` Make sure you have an internet connection\n`;
                        errorMsg += ` Wait for nodes to appear in the visualization\n`;
                        errorMsg += ` Then try recovery again\n`;
                    } else if (searchedNodes < 5 || connectedPeers === 0) {
                        errorMsg += ` Only ${searchedNodes} node${searchedNodes > 1 ? 's' : ''} synced so far.\n\n`;
                        errorMsg += `Your node may not have synced yet. Try:\n`;
                        errorMsg += ` Waiting a few more moments for sync to complete\n`;
                        errorMsg += ` Checking your network connection\n`;
                        errorMsg += ` Trying again in 30 seconds\n`;
                    } else {
                        errorMsg += `Searched ${searchedNodes} nodes but no match found.\n\n`;
                        errorMsg += `This could mean:\n`;
                        errorMsg += ` The phrase was entered incorrectly\n`;
                        errorMsg += ` The node was created on a different network\n`;
                        errorMsg += ` The node hasn't been synced from all peers\n`;
                    }
                    
                    alert(errorMsg);
                    return;
                }
                
                // Step 3: Restore node identity
                console.log(' Step 3: Restoring node identity...');
                
                // We found the node, but we can't restore the private key from just the phrase
                // (the phrase only encodes part of the key). However, we can restore the identity.
                // For now, we'll need to generate a new key pair and update the node.
                // In a full implementation, we'd need to store the encrypted private key.
                
                // For now, restore what we can:
                // - Node ID (from chain)
                // - Node name (from chain or user input)
                // - Public key (from chain)
                
                // Set current user (trim name to prevent space-related issues)
                const recoveredName = ((foundNode.name || name || '').trim()) || 'Unknown';
                currentUser = { id: foundNode.id, name: recoveredName };
                
                // Save to localStorage (but note: we don't have the private key)
                localStorage.setItem('srishti_node_id', foundNode.id);
                localStorage.setItem('srishti_node_name', recoveredName);
                localStorage.setItem('srishti_public_key', foundNode.publicKey || '');
                
                // Note: We can't restore the private key from just the recovery phrase
                // The user will need to re-join or we'd need a different recovery mechanism
                console.warn(' Private key cannot be restored from recovery phrase alone');
                
                // Initialize QR with the public key from chain
                if (window.SrishtiQRCode && foundNode.publicKey) {
                    window.SrishtiQRCode.init(foundNode.id, foundNode.publicKey);
                }
                
                // Update the app's nodeId to match the recovered node
                window.SrishtiApp.nodeId = foundNode.id;
                window.SrishtiApp.currentUser = currentUser;
                window.SrishtiApp.publicKeyBase64 = foundNode.publicKey || '';
                
                // Reinitialize network with the correct node ID
                // (We'll keep using the temp keys for now since we don't have the real private key)
                // In a production system, we'd need to store encrypted private keys or use deterministic key derivation
                
                hideOnboardingModal();
                showWelcome(foundNode.name || name);
                
                // Mark ourselves as online
                if (window.SrishtiApp) {
                    window.SrishtiApp.updatePresence(foundNode.id, { isOnline: true, lastSeen: Date.now() });
                }
                
                console.log(' Recovered node:', foundNode.name, foundNode.id);
                console.warn(' Note: Private key not restored. Some features may be limited.');
            } catch (error) {
                console.error('Recovery failed:', error);
                const loadingMsg = document.getElementById('recovery-loading');
                if (loadingMsg) loadingMsg.remove();
                alert('Recovery failed: ' + error.message + '\n\nPlease try again or join as a new node.');
            }
        }
        
        function hideOnboardingModal() {
            document.getElementById('onboarding-modal').classList.remove('active');
        }
        
        /**
         * Show guest mode - shows loading state first, then ready state after blockchain loads
         * @param {boolean} showLoadingFirst - If true, show loading state initially
         */
        function showGuestMode(showLoadingFirst = true) {
            // Remove any existing guest UI
            const existingBtn = document.getElementById('guest-join-btn');
            const existingIndicator = document.getElementById('guest-indicator');
            if (existingBtn) existingBtn.remove();
            if (existingIndicator) existingIndicator.remove();
            
            // Hide FAB icons on landing page
            const fabContainer = document.querySelector('.fab-container');
            if (fabContainer) {
                fabContainer.style.display = 'none';
            }
            
            // Create guest indicator container
            const guestIndicator = document.createElement('div');
            guestIndicator.id = 'guest-indicator';
            
            // Check if mobile
            const isMobile = window.innerWidth <= 768;
            
            // Loading state content
            const loadingContent = `
                <span class="guest-spinner"></span>
                <span class="guest-loading-text">Syncing blockchain...</span>
                <div class="guest-progress" style="width: 0%"></div>
            `;
            
            // Ready state content
            const getReadyContent = (mobile) => mobile 
                ? ' Guest  Tap to join'
                : ' Viewing as Guest <span style="opacity: 0.7; margin-left: 8px;"> Click to join</span>';
            
            guestIndicator.innerHTML = showLoadingFirst ? loadingContent : getReadyContent(isMobile);
            if (showLoadingFirst) {
                guestIndicator.classList.add('loading');
            }
            
            // Base styles - positioned at bottom-left corner
            let baseStyles = `
                position: fixed;
                bottom: 32px;
                left: 32px;
                padding: 12px 24px;
                background: rgba(255, 255, 255, 0.06);
                border: 1px solid rgba(255, 255, 255, 0.12);
                border-radius: 12px;
                color: rgba(255, 255, 255, 0.8);
                font-family: 'Outfit', sans-serif;
                font-size: 13px;
                font-weight: 500;
                z-index: 1000;
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                cursor: default;
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                text-align: center;
                overflow: hidden;
            `;
            
            // Mobile-specific adjustments
            if (isMobile) {
                baseStyles += `
                    bottom: 24px;
                    left: 24px;
                    padding: 10px 18px;
                    font-size: 12px;
                `;
            }
            
            guestIndicator.style.cssText = baseStyles;
            
            // Store resize handler reference for cleanup
            guestIndicator._resizeHandler = () => {
                const nowMobile = window.innerWidth <= 768;
                if (!guestIndicator.classList.contains('loading')) {
                    guestIndicator.innerHTML = getReadyContent(nowMobile);
                }
                if (nowMobile) {
                    guestIndicator.style.bottom = '24px';
                    guestIndicator.style.left = '24px';
                    guestIndicator.style.padding = '10px 18px';
                    guestIndicator.style.fontSize = '12px';
                } else {
                    guestIndicator.style.bottom = '32px';
                    guestIndicator.style.left = '32px';
                    guestIndicator.style.padding = '12px 24px';
                    guestIndicator.style.fontSize = '13px';
                }
            };
            window.addEventListener('resize', guestIndicator._resizeHandler);
            
            document.body.appendChild(guestIndicator);
        }
        
        /**
         * Update guest indicator progress during blockchain sync
         * @param {number} progress - Progress percentage (0-100)
         * @param {string} message - Optional status message
         */
        function updateGuestLoadingProgress(progress, message = null) {
            const indicator = document.getElementById('guest-indicator');
            if (!indicator || !indicator.classList.contains('loading')) return;
            
            const progressBar = indicator.querySelector('.guest-progress');
            const textEl = indicator.querySelector('.guest-loading-text');
            
            if (progressBar) {
                progressBar.style.width = `${Math.min(100, progress)}%`;
            }
            if (textEl && message) {
                textEl.textContent = message;
            }
        }
        
        /**
         * Transition guest indicator from loading to ready state
         */
        function showGuestReady() {
            const indicator = document.getElementById('guest-indicator');
            if (!indicator) return;
            
            const isMobile = window.innerWidth <= 768;
            const syncStatus = window._guestSyncStatus || {};
            const nodeCount = syncStatus.nodeCount || 0;
            
            // Show checkmark with node count
            const loadedMessage = nodeCount > 0 
                ? `${nodeCount} node${nodeCount > 1 ? 's' : ''} loaded!`
                : 'Ready!';
            
            indicator.innerHTML = `
                <svg class="guest-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                <span>${loadedMessage}</span>
            `;
            
            // After a moment, show the join button
            setTimeout(() => {
                indicator.classList.remove('loading');
                
                // Build the content with sync indicator if still syncing in background
                const buildContent = (mobile) => {
                    const stillSyncing = isBlockchainSyncing();
                    const syncDot = stillSyncing 
                        ? '<span class="sync-pulse" style="display: inline-block; width: 6px; height: 6px; background: #60A5FA; border-radius: 50%; margin-left: 6px;"></span>'
                        : '';
                    
                    if (mobile) {
                        return ` Guest  Tap to join${syncDot}`;
                    }
                    return ` Viewing as Guest${syncDot} <span style="opacity: 0.7; margin-left: 8px;"> Click to join</span>`;
                };
                
                indicator.innerHTML = buildContent(isMobile);
                indicator.style.cursor = 'pointer';
                
                // Update sync indicator periodically
                const syncCheckInterval = setInterval(() => {
                    if (!document.getElementById('guest-indicator')) {
                        clearInterval(syncCheckInterval);
                        return;
                    }
                    const nowMobile = window.innerWidth <= 768;
                    indicator.innerHTML = buildContent(nowMobile);
                }, 3000);
                indicator._syncInterval = syncCheckInterval;
                
                // Add hover effects
                indicator.onmouseenter = () => {
                    indicator.style.background = 'rgba(255, 255, 255, 0.1)';
                    indicator.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    indicator.style.transform = 'translateY(-2px)';
                };
                
                indicator.onmouseleave = () => {
                    indicator.style.background = 'rgba(255, 255, 255, 0.06)';
                    indicator.style.borderColor = 'rgba(255, 255, 255, 0.12)';
                    indicator.style.transform = 'translateY(0)';
                };
                
                // Add click handler to join
                indicator.onclick = () => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const joinParam = urlParams.get('join');
                    let joinParentId = null;
                    
                    if (joinParam) {
                        try {
                            const connectionInfo = window.SrishtiQRCodeClass.parseFromUrl(joinParam);
                            if (connectionInfo) {
                                joinParentId = connectionInfo.nodeId;
                            }
                        } catch (e) {
                            console.warn('Failed to parse join param:', e);
                        }
                    }
                    
                    showOnboardingModal(joinParentId);
                    
                    // Cleanup
                    if (indicator._resizeHandler) {
                        window.removeEventListener('resize', indicator._resizeHandler);
                    }
                    if (indicator._syncInterval) {
                        clearInterval(indicator._syncInterval);
                    }
                    indicator.remove();
                };
            }, 1200);
        }
        
        /**
         * Wait for blockchain to sync in guest mode with progress updates
         * @returns {Promise<void>}
         */
        async function waitForGuestSync() {
            return new Promise((resolve) => {
                const startTime = Date.now();
                const maxWaitTime = 15000; // 15 seconds max wait (increased for better sync)
                const minWaitTime = 2000;  // Minimum time to show loading for better UX
                const nodeWaitTime = 5000; // Wait at least 5s if we're connecting to peers
                
                let lastChainLength = window.SrishtiApp?.chain?.getLength() || 0;
                let lastNodeCount = 0;
                let stableCount = 0;
                const stableThreshold = 5; // Chain needs to be stable for 5 checks (~2s)
                let hadPeersAtSomePoint = false;
                
                const checkSync = () => {
                    const elapsed = Date.now() - startTime;
                    const chainLength = window.SrishtiApp?.chain?.getLength() || 0;
                    // Use peerInfo.size for VERIFIED compatible peers (after HELLO exchange)
                    // NOT wsClient.peers.size which includes all peers before epoch filtering
                    const connectedPeers = window.SrishtiApp?.network?.peerInfo?.size || 0;
                    const isSignalingConnected = window.SrishtiApp?.network?.signaling?.isConnected?.() || false;
                    // These track peers during HELLO exchange
                    const compatiblePeers = window.SrishtiApp?.network?.compatiblePeerCount || 0;
                    const rejectedPeers = window.SrishtiApp?.network?.rejectedPeerCount || 0;
                    // Raw count from server (before filtering) - for debugging
                    const rawPeerCount = window.SrishtiApp?.network?.wsClient?.peers?.size || 0;
                    
                    // Count actual nodes in chain (excluding genesis/virtual)
                    const nodeMap = window.SrishtiApp?.chain?.buildNodeMap?.() || {};
                    const nodeCount = Object.keys(nodeMap).length;
                    
                    // Track if we ever had COMPATIBLE peers (means network has active epoch-matching nodes)
                    // Don't count rejected peers (old epoch) as "having peers"
                    if (connectedPeers > 0) {
                        hadPeersAtSomePoint = true;
                    }
                    
                    // Calculate progress based on different stages
                    let progress = 10;
                    let message = 'Connecting to network...';
                    
                    if (isSignalingConnected) {
                        progress = 20;
                        message = 'Looking for peers...';
                    }
                    
                    // Show appropriate message based on peer status
                    if (connectedPeers > 0) {
                        // We have verified compatible peers!
                        progress = 50;
                        message = `Connected to ${connectedPeers} peer${connectedPeers > 1 ? 's' : ''}, syncing...`;
                    } else if (rejectedPeers > 0 && rawPeerCount > 0) {
                        // Found peers but all were incompatible (old epoch)
                        progress = 30;
                        message = 'Starting fresh network...';
                    } else if (rawPeerCount > 0) {
                        // Found peers, waiting for HELLO verification
                        progress = 25;
                        message = 'Verifying peers...';
                    }
                    
                    if (chainLength > 1) {
                        progress = 60 + Math.min(20, chainLength * 2);
                        message = `Syncing... ${chainLength} blocks`;
                    }
                    
                    if (nodeCount > 0) {
                        progress = 80 + Math.min(15, nodeCount * 3);
                        message = `Loading ${nodeCount} node${nodeCount > 1 ? 's' : ''}...`;
                    }
                    
                    // Check if chain/nodes are stable (not receiving new data)
                    if (chainLength === lastChainLength && nodeCount === lastNodeCount && nodeCount > 0) {
                        stableCount++;
                    } else {
                        stableCount = 0;
                        lastChainLength = chainLength;
                        lastNodeCount = nodeCount;
                    }
                    
                    updateGuestLoadingProgress(progress, message);
                    
                    // Sync complete conditions with smarter logic:
                    const hasNodes = nodeCount > 0;
                    const isStable = stableCount >= stableThreshold;
                    const pastMinWait = elapsed >= minWaitTime;
                    const pastNodeWait = elapsed >= nodeWaitTime;
                    const timedOut = elapsed >= maxWaitTime;
                    
                    // Don't finish too early if we're actively connecting/syncing
                    // Only wait if we have verified compatible peers
                    const stillConnecting = false; // No longer wait for unverified peers
                    const stillSyncing = (connectedPeers > 0 && !isStable && elapsed < maxWaitTime - 3000);
                    
                    // Complete if:
                    // 1. We have nodes, chain is stable, and past minimum wait
                    // 2. Timed out completely
                    // 3. We have nodes, no peers available (offline mode), past node wait time
                    
                    const syncComplete = (hasNodes && isStable && pastMinWait && !stillSyncing) ||
                                        timedOut ||
                                        (hasNodes && !hadPeersAtSomePoint && pastNodeWait);
                    
                    if (syncComplete) {
                        // Store sync status for recovery modal to check
                        window._guestSyncStatus = {
                            complete: true,
                            nodeCount: nodeCount,
                            chainLength: chainLength,
                            hadPeers: hadPeersAtSomePoint,
                            connectedPeers: connectedPeers,
                            timedOut: timedOut
                        };
                        
                        updateGuestLoadingProgress(100, hasNodes ? `${nodeCount} nodes loaded!` : 'Ready!');
                        
                        if (timedOut && !hasNodes) {
                            console.log(` Guest sync timeout - no nodes found (chain: ${chainLength} blocks)`);
                        } else if (timedOut) {
                            console.log(` Guest sync timeout - ${nodeCount} nodes, ${chainLength} blocks`);
                        } else if (!hadPeersAtSomePoint) {
                            console.log(` Offline mode - ${nodeCount} nodes from local storage`);
                        } else {
                            console.log(` Guest sync complete - ${nodeCount} nodes, ${chainLength} blocks from ${connectedPeers} peers`);
                        }
                        
                        resolve();
                        return;
                    }
                    
                    // Keep checking
                    setTimeout(checkSync, 400);
                };
                
                // Initialize sync status
                window._guestSyncStatus = { complete: false, nodeCount: 0 };
                
                // Start checking after a brief delay
                setTimeout(checkSync, 300);
            });
        }
        
        /**
         * Check if blockchain is still actively syncing
         * @returns {boolean}
         */
        function isBlockchainSyncing() {
            const status = window._guestSyncStatus;
            if (!status || !status.complete) return true;
            
            // Also check if new blocks are coming in
            const currentLength = window.SrishtiApp?.chain?.getLength() || 0;
            const nodeMap = window.SrishtiApp?.chain?.buildNodeMap?.() || {};
            const currentNodes = Object.keys(nodeMap).length;
            
            // If we have more data now than when sync "completed", we're still syncing
            if (currentNodes > status.nodeCount || currentLength > status.chainLength) {
                return true;
            }
            
            return false;
        }
        
        // Make it globally accessible for Recovery.js
        window.isBlockchainSyncing = isBlockchainSyncing;
        
        // Track known peer chain lengths for "behind" detection
        let knownPeerChainLength = 0;
        let lastSyncTime = 0;
        let syncInProgress = false;
        
        /**
         * Update chain status indicator (behind/syncing/synced)
         */
        function updateChainStatus() {
            const indicator = document.getElementById('chain-status-indicator');
            const statusText = document.getElementById('chain-status-text');
            if (!indicator || !statusText) return;
            
            const ourLength = window.SrishtiApp?.chain?.getLength() || 0;
            const network = window.SrishtiApp?.network;
            
            // Check if we're actively syncing
            if (syncInProgress || network?.syncing) {
                indicator.style.display = 'flex';
                indicator.className = 'chain-status-indicator syncing';
                statusText.textContent = `Syncing... ${ourLength} blocks`;
                return;
            }
            
            // Get peer chain lengths from network's peerInfo map
            if (network && network.peerInfo) {
                let maxPeerLength = ourLength;
                for (const [peerId, info] of network.peerInfo) {
                    if (info.chainLength && info.chainLength > maxPeerLength) {
                        maxPeerLength = info.chainLength;
                    }
                }
                knownPeerChainLength = Math.max(knownPeerChainLength, maxPeerLength);
            }
            
            // Show indicator if behind
            if (knownPeerChainLength > ourLength) {
                const behind = knownPeerChainLength - ourLength;
                indicator.style.display = 'flex';
                indicator.className = 'chain-status-indicator';
                statusText.textContent = `${behind} block${behind > 1 ? 's' : ''} behind (${ourLength}/${knownPeerChainLength})`;
            } else if (indicator.style.display !== 'none' && !syncInProgress) {
                // Show synced briefly then hide
                indicator.className = 'chain-status-indicator synced';
                statusText.textContent = `Synced (${ourLength} blocks)`;
                setTimeout(() => {
                    if (!syncInProgress && knownPeerChainLength <= ourLength) {
                        indicator.style.display = 'none';
                    }
                }, 3000);
            }
        }
        
        /**
         * Trigger manual sync with all connected peers
         */
        async function triggerManualSync() {
            const network = window.SrishtiApp?.network;
            const indicator = document.getElementById('chain-status-indicator');
            const statusText = document.getElementById('chain-status-text');
            
            if (!network || !indicator) {
                console.warn(' Network not available for sync');
                return;
            }
            
            if (syncInProgress) {
                console.log(' Sync already in progress');
                return;
            }
            
            syncInProgress = true;
            lastSyncTime = Date.now();
            
            // Update UI
            indicator.className = 'chain-status-indicator syncing';
            statusText.textContent = 'Requesting sync...';
            
            console.log(' Manual sync triggered');
            
            try {
                // Request sync from all connected peers
                const peers = Array.from(network.peers?.keys() || []);
                if (peers.length === 0) {
                    statusText.textContent = 'No peers connected';
                    setTimeout(() => {
                        syncInProgress = false;
                        updateChainStatus();
                    }, 2000);
                    return;
                }
                
                statusText.textContent = `Syncing from ${peers.length} peer${peers.length > 1 ? 's' : ''}...`;
                
                // Request sync from each peer
                for (const peerId of peers) {
                    await network.requestSync(peerId);
                }
                
                // Wait for sync to complete (with timeout)
                let syncWaitTime = 0;
                const maxSyncWait = 15000; // 15 seconds max
                
                const waitForSync = setInterval(() => {
                    syncWaitTime += 500;
                    const currentLength = window.SrishtiApp?.chain?.getLength() || 0;
                    
                    if (currentLength >= knownPeerChainLength || syncWaitTime >= maxSyncWait) {
                        clearInterval(waitForSync);
                        syncInProgress = false;
                        
                        // Update known peer length
                        knownPeerChainLength = currentLength;
                        
                        updateChainStatus();
                        
                        if (currentLength >= knownPeerChainLength) {
                            console.log(` Sync complete: ${currentLength} blocks`);
                        } else {
                            console.log(` Sync timeout: ${currentLength} blocks`);
                        }
                    } else {
                        statusText.textContent = `Syncing... ${currentLength} blocks`;
                    }
                }, 500);
                
            } catch (error) {
                console.error('Sync failed:', error);
                syncInProgress = false;
                statusText.textContent = 'Sync failed';
                setTimeout(() => updateChainStatus(), 2000);
            }
        }
        
        // Make sync functions globally accessible
        window.triggerManualSync = triggerManualSync;
        window.updateChainStatus = updateChainStatus;
        
        // Periodically check chain status
        setInterval(() => {
            if (!syncInProgress) {
                updateChainStatus();
            }
        }, 10000); // Check every 10 seconds
        
        function showQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.add('active');
            
            // Generate QR
            if (window.SrishtiQRCode && currentUser && window.SrishtiApp.publicKeyBase64) {
                window.SrishtiQRCode.init(currentUser.id, window.SrishtiApp.publicKeyBase64);
                window.SrishtiQRCode.generateQR('qr-display');
            }
        }
        
        function hideQRModal() {
            document.getElementById('qr-modal').classList.remove('active');
        }
        
        function showNodeModal(nodeData) {
            const modal = document.getElementById('node-modal');
            const nodeId = nodeData.id;
            const chain = window.SrishtiApp?.chain;
            
            // Get fresh data from nodesData (includes latest presence info)
            const freshData = nodesData[nodeId] || nodeData;
            
            document.getElementById('node-avatar').textContent = (freshData.name || '?')[0].toUpperCase();
            document.getElementById('node-name').textContent = freshData.name || 'Unknown';
            document.getElementById('node-children').textContent = freshData.childCount || 0;
            
            const statusEl = document.getElementById('node-status');
            const statusText = document.getElementById('node-status-text');
            // Current user is always online (they're using the app right now!)
            const isCurrentUser = currentUser && currentUser.id === nodeId;
            const isOnline = isCurrentUser || freshData.isOnline;
            if (isOnline) {
                statusEl.className = 'node-status online';
                statusText.textContent = 'Online';
            } else {
                statusEl.className = 'node-status offline';
                statusText.textContent = 'Offline';
            }
            
            // Format join date
            if (freshData.createdAt) {
                const date = new Date(freshData.createdAt);
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) {
                    document.getElementById('node-joined').textContent = 'Today';
                } else if (diffDays === 1) {
                    document.getElementById('node-joined').textContent = 'Yesterday';
                } else if (diffDays < 30) {
                    document.getElementById('node-joined').textContent = `${diffDays}d ago`;
                } else {
                    document.getElementById('node-joined').textContent = date.toLocaleDateString();
                }
            } else {
                document.getElementById('node-joined').textContent = '-';
            }
            
            // Display Role
            let role = 'USER';
            if (chain) {
                role = chain.getNodeRole(nodeId) || 'USER';
            }
            const roleText = role === 'ROOT' ? ' ROOT' : 
                            role === 'INSTITUTION' ? ' INSTITUTION' : 
                            role === 'GOVERNANCE_ADMIN' ? ' GOVERNANCE_ADMIN' : 
                            ' USER';
            document.getElementById('node-role-text').textContent = roleText;
            
            // Display Rank/Participation Score
            let rankText = 'N/A';
            let rankValue = 0;
            if (window.SrishtiGlow && freshData) {
                const glow = window.SrishtiGlow.calculateGlow(freshData);
                rankValue = Math.round(glow.composite * 100);
                rankText = `Rank: ${rankValue}%`;
            } else if (window.SrishtiApp?.consensus) {
                try {
                    rankValue = Math.round((window.SrishtiApp.consensus.getParticipationScore(nodeId) || 0) * 100);
                    rankText = `Rank: ${rankValue}%`;
                } catch (e) {
                    rankText = 'Rank: N/A';
                }
            }
            document.getElementById('node-rank-text').textContent = rankText;
            
            // Display Institution Info
            const institutionSection = document.getElementById('node-institution-section');
            if (chain && role === 'INSTITUTION') {
                const institutions = chain.getInstitutions();
                const institution = institutions.verified[nodeId];
                if (institution) {
                    institutionSection.style.display = 'block';
                    document.getElementById('node-institution-name').textContent = institution.name || 'Unknown Institution';
                    document.getElementById('node-institution-category').textContent = institution.category || '';
                } else {
                    institutionSection.style.display = 'none';
                }
            } else {
                institutionSection.style.display = 'none';
            }
            
            // Display Soulbound Tokens
            const tokensSection = document.getElementById('node-tokens-section');
            const tokensList = document.getElementById('node-tokens-list');
            if (chain && nodeId) {
                const tokens = chain.getSoulboundTokens(nodeId) || [];
                if (tokens.length > 0) {
                    tokensSection.style.display = 'block';
                    tokensList.innerHTML = '';
                    
                    tokens.forEach(token => {
                        const tokenItem = document.createElement('div');
                        tokenItem.className = 'node-token-item';
                        
                        const date = new Date(token.mintedAt || Date.now());
                        const dateStr = date.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'short', 
                            day: 'numeric' 
                        });
                        
                        tokenItem.innerHTML = `
                            <div class="node-token-title">${escapeHtml(token.title || token.achievementId || 'Token')}</div>
                            <div class="node-token-issuer">Issued by: ${escapeHtml(token.issuerName || 'Unknown')}</div>
                            ${token.description ? `<div class="node-token-issuer" style="margin-top: 4px;">${escapeHtml(token.description)}</div>` : ''}
                            <div class="node-token-date">Minted: ${dateStr}</div>
                        `;
                        tokensList.appendChild(tokenItem);
                    });
                } else {
                    tokensSection.style.display = 'none';
                }
            } else {
                tokensSection.style.display = 'none';
            }
            
            // Show/hide request parent button
            // Support multiple parents - show button if this node isn't already a parent
            const requestParentBtn = document.getElementById('request-parent-btn');
            if (requestParentBtn) {
                if (currentUser && nodeData.id !== currentUser.id) {
                    // Check if this node is already a parent
                    const nodeMap = chain?.buildNodeMap();
                    const currentNode = nodeMap?.[currentUser.id];
                    const currentParentIds = Array.isArray(currentNode?.parentIds) 
                        ? currentNode.parentIds 
                        : (currentNode?.parentId ? [currentNode.parentId] : []);
                    
                    const isAlreadyParent = currentParentIds.includes(nodeData.id);
                    if (!isAlreadyParent) {
                        requestParentBtn.style.display = 'block';
                        // Remove old handler and add new one to avoid duplicates
                        requestParentBtn.replaceWith(requestParentBtn.cloneNode(true));
                        const newRequestBtn = document.getElementById('request-parent-btn');
                        newRequestBtn.onclick = async () => {
                            await handleRequestParent(nodeData.id);
                            // Refresh dashboard after request
                            setTimeout(() => {
                                if (window.updateDashboard) window.updateDashboard();
                                // Refresh node modal to update button state
                                showNodeModal(nodeData);
                            }, 500);
                        };
                    } else {
                        requestParentBtn.style.display = 'none';
                    }
                } else {
                    requestParentBtn.style.display = 'none';
                }
            }
            
            modal.classList.add('active');
        }
        
        async function handleRequestParent(parentId) {
            if (!window.SrishtiApp || !currentUser) {
                alert('Please join the network first');
                return;
            }
            
            if (!parentId) {
                alert('Please select a parent node');
                return;
            }
            
            try {
                const reason = prompt('Why do you want to become a child of this node? (optional)');
                
                await window.SrishtiApp.requestParentConnection(parentId, {
                    reason: reason || null,
                    metadata: {}
                });
                
                alert(' Parent connection request submitted! The parent will need to approve your request.');
                hideNodeModal();
            } catch (error) {
                console.error('Failed to request parent connection:', error);
                alert(` Failed to request parent connection: ${error.message}`);
            }
        }
        
        function hideNodeModal() {
            document.getElementById('node-modal').classList.remove('active');
        }
        
        function updateStats() {
            const nodes = Object.values(nodesData).filter(n => !n.isVirtualRoot);
            
            document.getElementById('total-nodes').textContent = nodes.length;
            // Count online nodes - current user is ALWAYS online
            const onlineCount = nodes.filter(n => {
                const isCurrentUser = currentUser && n.id === currentUser.id;
                return isCurrentUser || n.isOnline;
            }).length;
            document.getElementById('online-nodes').textContent = onlineCount;
            
            // Update your node indicator
            if (currentUser) {
                const indicator = document.getElementById('your-node-indicator');
                const freshData = nodesData[currentUser.id];
                
                // Use chain data if available, otherwise fallback to currentUser data
                const displayName = freshData?.name || currentUser.name || '?';
                const childCount = freshData?.childCount || 0;
                
                document.getElementById('your-avatar').textContent = displayName[0].toUpperCase();
                document.getElementById('your-name').textContent = displayName;
                document.getElementById('your-children').textContent = `${childCount} recruits`;
                indicator.style.display = 'flex';
            }
        }
        
        function showWelcome(name) {
            const burst = document.createElement('div');
            burst.className = 'welcome-burst';
            burst.innerHTML = `<div class="welcome-text">Welcome, ${name}!</div>`;
            document.body.appendChild(burst);
            
            setTimeout(() => burst.remove(), 2500);
        }
        
        // ============================================
        // Network Functions
        // ============================================
        
        async function joinNetwork(name, parentId) {
            try {
                // Clean up guest mode UI if present
                const guestBtn = document.getElementById('guest-join-btn');
                const guestIndicator = document.getElementById('guest-indicator');
                const qrHint = document.getElementById('qr-join-hint');
                if (guestBtn) guestBtn.remove();
                if (guestIndicator) guestIndicator.remove();
                if (qrHint) qrHint.remove();
                
                // Show FAB icons again after joining
                const fabContainer = document.querySelector('.fab-container');
                if (fabContainer) {
                    fabContainer.style.display = 'flex';
                }
                
                // If we were in guest mode, we need to reinitialize network with real identity
                if (window.SrishtiApp && window.SrishtiApp.isGuest && window.SrishtiApp.network) {
                    console.log(' Disconnecting guest network to join with real identity...');
                    try {
                        window.SrishtiApp.network.close();
                    } catch (e) {
                        console.warn('Error disconnecting guest network:', e);
                    }
                    window.SrishtiApp.network = null;
                    window.SrishtiApp.isGuest = false;
                }
                
                const result = await window.SrishtiApp.createNode(name, parentId);
                const nodeId = result.nodeId;
                const recoveryPhrase = result.recoveryPhrase;
                
                currentUser = { id: nodeId, name: name };
                
                // Update stats immediately now that currentUser is set
                updateStats();
                
                // Mark ourselves as online
                if (window.SrishtiApp) {
                    window.SrishtiApp.updatePresence(nodeId, { isOnline: true, lastSeen: Date.now() });
                }
                
                // Initialize QR
                if (window.SrishtiQRCode && window.SrishtiApp.publicKeyBase64) {
                    window.SrishtiQRCode.init(nodeId, window.SrishtiApp.publicKeyBase64);
                }
                
                // Clear join param from URL
                const url = new URL(window.location.href);
                url.searchParams.delete('join');
                window.history.replaceState({}, document.title, url.pathname);
                
                hideOnboardingModal();
                
                // Show recovery phrase FIRST, then welcome
                if (window.SrishtiRecovery && recoveryPhrase) {
                    window.SrishtiRecovery.showPhraseModal(recoveryPhrase, () => {
                        showWelcome(name);
                    });
                } else {
                    showWelcome(name);
                }
                
                console.log(' Joined network as:', name, nodeId);
            } catch (error) {
                console.error('Failed to join network:', error);
                alert('Failed to join. Please try again.');
                const joinBtn = document.getElementById('join-btn');
                joinBtn.disabled = false;
                joinBtn.innerHTML = 'Enter the Timeline';
            }
        }
        
        async function handleScannedQR(parentId) {
            // Verify parent exists
            const parentExists = window.SrishtiApp.nodeExists(parentId);
            if (!parentExists) {
                alert('Invalid QR code. The node does not exist.');
                return;
            }
            
            // If already in network, just show info
            if (currentUser) {
                const parentData = nodesData[parentId];
                alert(`This is ${parentData?.name || 'a node'}'s invite QR. You're already in the network!`);
                return;
            }
            
            // Show onboarding with parent
            showOnboardingModal(parentId);
        }
        
        // ============================================
        // Initialization
        // ============================================
        
        /**
         * Update the loading screen status
         * @param {string} status - Main status message
         * @param {string} substatus - Optional secondary message
         */
        function updateLoadingStatus(status, substatus = '') {
            const statusEl = document.getElementById('loading-status');
            const substatusEl = document.getElementById('loading-substatus');
            if (statusEl) statusEl.textContent = status;
            if (substatusEl) substatusEl.textContent = substatus;
        }
        
        async function init() {
            // Initialize blockchain app
            try {
                updateLoadingStatus('Initializing blockchain...', 'Opening storage');
                await window.SrishtiApp.init();
                updateLoadingStatus('Loading chain data...', '');
            } catch (error) {
                console.error('Failed to initialize blockchain:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="loading-logo">SRISHTI</div>
                    <p style="color: #ffffff; margin-top: 20px;"> Blockchain initialization failed</p>
                    <p style="color: rgba(255, 255, 255, 0.6); font-size: 0.9em;">${error.message}</p>
                `;
                return;
            }
            
            // Check for join parameter in URL
            const urlParams = new URLSearchParams(window.location.search);
            const joinParam = urlParams.get('join');
            let joinParentId = null;
            
            if (joinParam) {
                try {
                    const connectionInfo = window.SrishtiQRCodeClass.parseFromUrl(joinParam);
                    if (connectionInfo) {
                        joinParentId = connectionInfo.nodeId;
                    }
                } catch (e) {
                    console.warn('Failed to parse join param:', e);
                }
            }
            
            updateLoadingStatus('Checking identity...', '');
            
            // Check for existing user - do this AFTER app.init() to ensure app has loaded keys
            const savedNodeId = localStorage.getItem('srishti_node_id');
            const savedNodeName = (localStorage.getItem('srishti_node_name') || '').trim();
            const savedPrivateKey = localStorage.getItem('srishti_private_key');
            
            // Also verify app has loaded the node correctly
            const appHasLoadedNode = window.SrishtiApp && window.SrishtiApp.nodeId && window.SrishtiApp.keyPair;
            console.log(` Initialization check: savedNodeId=${savedNodeId}, savedNodeName="${savedNodeName}", appHasLoadedNode=${appHasLoadedNode}, app.nodeId=${window.SrishtiApp?.nodeId}`);
            
            updateLoadingStatus('Building visualization...', 'Preparing 3D environment');
            
            // Subscribe to nodes from blockchain
            unsubscribeNodes = window.SrishtiApp.subscribeToNodes((nodes) => {
                nodesData = nodes;
                updateStats();
                
                // Build visualization (only rebuilds if structure changed)
                const hierarchy = window.SrishtiApp.buildHierarchy();
                buildVisualization(hierarchy);
                
                // Update glows (this is lightweight and can run every time)
                updateNodeGlows();
                
                // Update dashboard if open
                if (document.getElementById('dashboard-panel').classList.contains('open')) {
                    updateDashboard();
                }
                
                // Always update role section (includes admin panel) when chain updates
                // This ensures ROOT sees pending institution requests even if dashboard isn't fully open
                if (window.SrishtiApp && currentUser) {
                    const myRole = window.SrishtiApp.getMyRole();
                    if (myRole === 'ROOT' || myRole === 'GOVERNANCE_ADMIN') {
                        updateRoleSection();
                    }
                }
            });
            
            updateLoadingStatus('Almost ready...', '');
            
            // Wait a moment for initial data
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Hide loading with fade out
            const loadingEl = document.getElementById('loading');
            loadingEl.style.transition = 'opacity 0.3s ease';
            loadingEl.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 300));
            loadingEl.style.display = 'none';
            
            // Check if returning user - trust localStorage if we have valid data
            // Note: We check localStorage directly here (not app.nodeId) because app.js loads from localStorage
            // during init, so they should match. If they don't, we still trust localStorage as source of truth.
            // IMPORTANT: We allow login with just nodeId and name, even without private key (for recovery cases)
            // Users without private key will be in read-only mode but still recognized as logged in
            // Fix: Trim and validate node name to handle spaces properly
            const hasValidLocalData = savedNodeId && savedNodeName && savedNodeName.length > 0;
            const hasPrivateKey = !!savedPrivateKey;
            const appHasNode = window.SrishtiApp?.nodeId === savedNodeId;
            
            if (savedNodeId && !appHasNode && window.SrishtiApp?.nodeId) {
                console.warn(` Mismatch detected: localStorage has ${savedNodeId} but app has ${window.SrishtiApp.nodeId}. App may not have loaded from localStorage correctly.`);
            } else if (savedNodeId && !window.SrishtiApp?.nodeId && !hasPrivateKey) {
                console.warn(` localStorage has node ID ${savedNodeId} but app.nodeId is not set and no private key available. This may indicate a recovery scenario or an error during app.js initialization.`);
            }
            
            if (hasValidLocalData) {
                // User has valid identity in localStorage - they're a returning user
                currentUser = { id: savedNodeId, name: savedNodeName };
                console.log(` Returning user set: ${savedNodeName} (${savedNodeId})`);
                
                // If app doesn't have the nodeId but we have it in localStorage, set it in app
                // This handles cases where private key is missing (recovery scenario)
                if (window.SrishtiApp && !window.SrishtiApp.nodeId && savedNodeId) {
                    window.SrishtiApp.nodeId = savedNodeId;
                    window.SrishtiApp.currentUser = currentUser;
                    const savedPublicKey = localStorage.getItem('srishti_public_key');
                    if (savedPublicKey) {
                        window.SrishtiApp.publicKeyBase64 = savedPublicKey;
                    }
                    console.log(` Set nodeId in app from localStorage: ${savedNodeId} (read-only mode: no private key)`);
                }
                
                // Clean up any guest mode UI if present (in case it was shown during loading)
                const guestBtn = document.getElementById('guest-join-btn');
                const guestIndicator = document.getElementById('guest-indicator');
                const qrHint = document.getElementById('qr-join-hint');
                if (guestBtn) guestBtn.remove();
                if (guestIndicator) guestIndicator.remove();
                if (qrHint) qrHint.remove();
                
                // Ensure FAB icons are visible for logged-in users
                const fabContainer = document.querySelector('.fab-container');
                if (fabContainer) {
                    fabContainer.style.display = 'flex';
                }
                
                // If they were in guest mode, disconnect guest network and reinitialize with real identity
                if (window.SrishtiApp && window.SrishtiApp.isGuest) {
                    console.log(' Disconnecting guest network for returning user...');
                    if (window.SrishtiApp.network) {
                        try {
                            window.SrishtiApp.network.close();
                        } catch (e) {
                            console.warn('Error disconnecting guest network:', e);
                        }
                        window.SrishtiApp.network = null;
                    }
                    window.SrishtiApp.isGuest = false;
                    // Reinitialize network with real identity (only if we have keys)
                    // Without private key, we stay in guest mode for network purposes
                    if (window.SrishtiApp.nodeId && window.SrishtiApp.keyPair) {
                        await window.SrishtiApp.initNetwork(false); // false = not guest mode
                    } else {
                        console.warn(` Cannot initialize network with real identity - missing keyPair. Staying in guest mode for network.`);
                    }
                } else if (window.SrishtiApp && !window.SrishtiApp.network && window.SrishtiApp.nodeId && window.SrishtiApp.keyPair) {
                    // Network wasn't initialized for some reason - initialize it now
                    // Only if we have keys (keyPair)
                    console.log(' Initializing network for returning user...');
                    await window.SrishtiApp.initNetwork(false); // false = not guest mode
                } else if (window.SrishtiApp && !window.SrishtiApp.network && window.SrishtiApp.nodeId && !window.SrishtiApp.keyPair) {
                    // Node ID exists but no key pair (recovery scenario)
                    // Initialize network in guest mode so they can still sync blockchain
                    console.log(` Node ID exists (${window.SrishtiApp.nodeId}) but no private key - initializing network in guest mode for sync`);
                    try {
                        await window.SrishtiApp.initNetwork(true); // true = guest mode for sync
                        console.log(' Guest mode network initialized for returning user (read-only)');
                        
                        // Show chain status indicator to let them know they may need to sync
                        setTimeout(() => {
                            updateChainStatus();
                            // Show the indicator briefly to let them know sync is happening
                            const indicator = document.getElementById('chain-status-indicator');
                            if (indicator) {
                                indicator.style.display = 'flex';
                                indicator.className = 'chain-status-indicator syncing';
                                document.getElementById('chain-status-text').textContent = 'Syncing blockchain...';
                            }
                        }, 1000);
                    } catch (error) {
                        console.warn(' Failed to initialize guest network for returning user:', error);
                    }
                } else if (window.SrishtiApp && !window.SrishtiApp.network) {
                    // No network and no node - try guest mode anyway for chain sync
                    console.log(' No network detected, initializing guest mode for sync...');
                    try {
                        await window.SrishtiApp.initNetwork(true);
                        console.log(' Guest mode network initialized');
                    } catch (error) {
                        console.warn(' Guest network initialization failed:', error);
                    }
                }
                
                // Mark ourselves as online
                if (window.SrishtiApp) {
                    window.SrishtiApp.updatePresence(savedNodeId, { isOnline: true, lastSeen: Date.now() });
                }
                
                // Initialize QR
                if (window.SrishtiQRCode && window.SrishtiApp.publicKeyBase64) {
                    window.SrishtiQRCode.init(savedNodeId, window.SrishtiApp.publicKeyBase64);
                }
                
                // If they came from a QR link but are already in network
                if (joinParentId) {
                    const url = new URL(window.location.href);
                    url.searchParams.delete('join');
                    window.history.replaceState({}, document.title, url.pathname);
                }
                
                // Trigger a UI update with current user
                updateStats();
            } else {
                // New user - show guest mode with loading state first
                console.log(' New user - entering guest mode with loading state');
                showGuestMode(true); // true = show loading first
                
                // Initialize network in guest mode so they can see the network
                // This allows viewing other nodes without joining
                if (window.SrishtiApp && !window.SrishtiApp.network) {
                    try {
                        updateGuestLoadingProgress(10, 'Connecting to network...');
                        
                        await window.SrishtiApp.initNetwork(true); // true = guest mode
                        console.log(' Guest mode network initialized - syncing blockchain');
                        
                        updateGuestLoadingProgress(30, 'Syncing blockchain...');
                        
                        // Wait for blockchain sync with progress updates
                        await waitForGuestSync();
                        
                        console.log(' Guest mode ready - blockchain loaded');
                        showGuestReady();
                    } catch (error) {
                        console.warn(' Guest mode network initialization failed:', error);
                        // Still show ready state - they can view local chain
                        updateGuestLoadingProgress(100, 'Using local data');
                        setTimeout(() => showGuestReady(), 500);
                    }
                } else {
                    // Network already exists or app not ready - just show ready
                    showGuestReady();
                }
                
                // If they came via QR code, show a subtle hint after guest is ready
                if (joinParentId) {
                    setTimeout(() => {
                        // Only show hint if they haven't joined yet
                        if (!currentUser) {
                            const hint = document.createElement('div');
                            hint.id = 'qr-join-hint';
                            hint.innerHTML = ` You can join under ${nodesData[joinParentId]?.name || 'this node'}`;
                            hint.style.cssText = `
                                position: fixed;
                                bottom: 180px;
                                right: 30px;
                                padding: 12px 20px;
                                background: rgba(255, 255, 255, 0.08);
                                border: 1px solid rgba(255, 255, 255, 0.15);
                                border-radius: 10px;
                                color: rgba(255, 255, 255, 0.8);
                                font-family: 'Outfit', sans-serif;
                                font-size: 13px;
                                z-index: 1000;
                                backdrop-filter: blur(10px);
                                animation: fadeIn 0.5s ease;
                            `;
                            document.body.appendChild(hint);
                            
                            // Remove hint after 5 seconds
                            setTimeout(() => {
                                if (hint.parentNode) {
                                    hint.style.animation = 'fadeOut 0.5s ease';
                                    setTimeout(() => hint.remove(), 500);
                                }
                            }, 5000);
                        }
                    }, 3000); // Slightly delayed to allow guest ready animation
                }
            }
            
            // Start animation
            animate();
            
            // Check chain status after a brief delay (allows sync to start)
            setTimeout(() => {
                updateChainStatus();
                // If we have a network, trigger initial sync check
                if (window.SrishtiApp?.network && currentUser) {
                    const peers = Array.from(window.SrishtiApp.network.peers?.keys() || []);
                    if (peers.length > 0) {
                        console.log(` Initial sync check with ${peers.length} peer(s)`);
                        // Request sync from first peer to check if we're behind
                        window.SrishtiApp.network.requestSync(peers[0]);
                    }
                }
            }, 3000);
            
            // Update glows every 5 seconds
            setInterval(updateNodeGlows, 5000);
        }
        
        // ============================================
        // Event Listeners
        // ============================================
        
        // Dashboard
        document.getElementById('dashboard-fab').addEventListener('click', showDashboard);
        document.querySelector('.dashboard-close').addEventListener('click', hideDashboard);
        document.getElementById('dash-share-btn').addEventListener('click', () => {
            window.SrishtiQRCode && window.SrishtiQRCode.shareInviteUrl();
        });
        document.getElementById('dash-qr-btn').addEventListener('click', () => {
            hideDashboard();
            setTimeout(showQRModal, 200);
        });
        
        // Setup recovery button (initial state)
        document.getElementById('setup-recovery-btn')?.addEventListener('click', showSetupRecoveryModal);
        
        // Register institution button (initial state)
        document.getElementById('register-institution-btn')?.addEventListener('click', showRegisterInstitutionModal);
        
        // Your node indicator - click to open dashboard
        document.getElementById('your-node-indicator').addEventListener('click', showDashboard);
        
        // FAB buttons
        document.getElementById('qr-fab').addEventListener('click', showQRModal);
        document.getElementById('scan-fab').addEventListener('click', () => {
            if (window.SrishtiScanner) {
                window.SrishtiScanner.init(handleScannedQR);
                window.SrishtiScanner.open();
            }
        });
        
        // QR Modal buttons
        document.querySelector('#qr-modal .qr-close').addEventListener('click', hideQRModal);
        document.getElementById('share-qr-btn').addEventListener('click', () => {
            window.SrishtiQRCode && window.SrishtiQRCode.shareInviteUrl();
        });
        document.getElementById('copy-link-btn').addEventListener('click', async () => {
            if (window.SrishtiQRCode) {
                await window.SrishtiQRCode.copyInviteUrl();
            }
        });
        
        document.getElementById('show-recovery-btn').addEventListener('click', () => {
            const privateKey = localStorage.getItem('srishti_private_key');
            if (privateKey && window.SrishtiRecovery) {
                const phrase = window.SrishtiRecovery.generatePhrase(privateKey);
                window.SrishtiRecovery.showPhraseModal(phrase);
            } else {
                alert('No recovery phrase available');
            }
        });
        
        // Reset chain button (only visible to ROOT users)
        document.getElementById('reset-chain-btn')?.addEventListener('click', async () => {
            try {
                if (!window.SrishtiApp || !window.SrishtiApp.resetChain) {
                    alert(' Reset chain function not available. Please refresh the page.');
                    return;
                }
                
                const confirmed = confirm(
                    ' WARNING: This will delete ALL blocks and chain data!\n\n' +
                    'This includes:\n' +
                    '- All nodes\n' +
                    '- All soulbound tokens\n' +
                    '- All proposals\n' +
                    '- All institution registrations\n\n' +
                    'This will clear old nodes visible to guests.\n\n' +
                    'Are you sure you want to reset the chain?'
                );
                
                if (!confirmed) {
                    return;
                }
                
                const btn = document.getElementById('reset-chain-btn');
                btn.disabled = true;
                btn.innerHTML = ' Resetting...';
                
                const genesis = await window.SrishtiApp.resetChain({ 
                    message: 'Srishti timeline begins - Fresh start'
                });
                
                if (genesis) {
                    btn.innerHTML = ' Reset Complete!';
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    btn.disabled = false;
                    btn.innerHTML = ' Reset Chain (Clear All Nodes)';
                }
            } catch (error) {
                console.error('Failed to reset chain:', error);
                alert(` Failed to reset chain: ${error.message}`);
                const btn = document.getElementById('reset-chain-btn');
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = ' Reset Chain (Clear All Nodes)';
                }
            }
        });
        
        // Download chain data button
        document.getElementById('download-chain-btn')?.addEventListener('click', async () => {
            try {
                await window.SrishtiApp.downloadChainData();
                // Show success feedback
                const btn = document.getElementById('download-chain-btn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg class="icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Downloaded!';
                btn.style.opacity = '0.7';
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.opacity = '1';
                }, 2000);
            } catch (error) {
                console.error('Failed to download chain data:', error);
                alert('Failed to download chain data. Please check the console for details.');
            }
        });
        
        // Node Modal
        document.querySelector('#node-modal .node-close').addEventListener('click', hideNodeModal);
        document.getElementById('node-modal').addEventListener('click', (e) => {
            if (e.target.id === 'node-modal') hideNodeModal();
        });
        
        // Mint Token Modal
        document.querySelector('#mint-token-modal .mint-token-close').addEventListener('click', hideMintTokenModal);
        document.querySelector('.mint-token-cancel').addEventListener('click', hideMintTokenModal);
        document.getElementById('mint-token-modal').addEventListener('click', (e) => {
            if (e.target.id === 'mint-token-modal') hideMintTokenModal();
        });
        document.getElementById('mint-token-form').addEventListener('submit', handleMintTokenSubmit);
        
        // QR Modal backdrop
        document.getElementById('qr-modal').addEventListener('click', (e) => {
            if (e.target.id === 'qr-modal') hideQRModal();
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
            // Expose resetChain to console for easy access
            window.resetChain = async () => {
                if (!window.SrishtiApp || !window.SrishtiApp.resetChain) {
                    console.error(' SrishtiApp.resetChain not available');
                    return;
                }
                console.log(' Resetting chain...');
                try {
                    const genesis = await window.SrishtiApp.resetChain({ 
                        message: 'Srishti timeline begins - Fresh start',
                        skipConfirmation: false // Will still show confirmation
                    });
                    if (genesis) {
                        console.log(' Chain reset complete! Refreshing page...');
                        setTimeout(() => window.location.reload(), 1500);
                    }
                } catch (error) {
                    console.error(' Failed to reset chain:', error);
                }
            };
            
            // Start
            init();
    </script>
</body>

</html>
