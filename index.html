<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Srishti Blockchain - Join the Timeline</title>
    
    <!-- External Libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- QR Code Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    
    <!-- Blockchain Core (load in order) -->
    <script src="src/core/Hasher.js"></script>
    <script src="src/core/Event.js"></script>
    <script src="src/core/Block.js"></script>
    <script src="src/core/Chain.js"></script>
    <script src="src/crypto/Keys.js"></script>
    <script src="src/crypto/Recovery.js"></script>
    <script src="src/storage/IndexedDBStore.js"></script>
    <script src="src/consensus/ProofOfParticipation.js"></script>
    <script src="src/p2p/Protocol.js"></script>
    <script src="src/p2p/SignalingClient.js"></script>
    <script src="src/p2p/PeerConnection.js"></script>
    <script src="src/p2p/Network.js"></script>
    <script src="src/discovery/QRCode.js"></script>
    <script src="src/ui/BlockchainAdapter.js"></script>
    <script src="src/ui/GlowCalculator.js"></script>
    
    <!-- QR Scanner (blockchain-compatible) -->
    <script src="docs/qr-scanner-blockchain.js"></script>
    
    <!-- Main App -->
    <script src="app.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Syne:wght@400;500;600;700;800&display=swap');
        
        :root {
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --accent-gold: #f0c14b;
            --accent-orange: #ff7e33;
            --accent-pink: #ff3d8a;
            --accent-purple: #a855f7;
            --accent-blue: #3b82f6;
            --accent-cyan: #06b6d4;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --blur-strength: 20px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Outfit', sans-serif;
            background: #050510;
        }

        /* Animated gradient background blobs */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(168, 85, 247, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 61, 138, 0.12) 0%, transparent 40%),
                radial-gradient(circle at 40% 40%, rgba(6, 182, 212, 0.1) 0%, transparent 35%),
                radial-gradient(circle at 70% 70%, rgba(240, 193, 75, 0.1) 0%, transparent 35%);
            animation: blobMove 25s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes blobMove {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(2%, -2%) rotate(3deg); }
            50% { transform: translate(-1%, 3%) rotate(-2deg); }
            75% { transform: translate(-3%, -1%) rotate(2deg); }
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        /* Glass Panel Base Styles */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--blur-strength));
            -webkit-backdrop-filter: blur(var(--blur-strength));
            border: 1px solid var(--glass-border);
            box-shadow: 
                0 8px 32px var(--glass-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Onboarding Modal */
        #onboarding-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.7);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        #onboarding-modal.active {
            display: flex;
        }

        .onboarding-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 48px 40px;
            max-width: 420px;
            width: 90%;
            color: var(--text-primary);
            text-align: center;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                0 1px 0 rgba(255, 255, 255, 0.1) inset;
            animation: modalAppear 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }
        
        .onboarding-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        }
        
        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(30px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .onboarding-logo {
            font-family: 'Syne', sans-serif;
            font-size: 2.8em;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange), var(--accent-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .onboarding-tagline {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 32px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 300;
        }

        .onboarding-input-group {
            margin-bottom: 28px;
        }

        .onboarding-input-group label {
            display: block;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85em;
            margin-bottom: 10px;
            text-align: left;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .onboarding-input {
            width: 100%;
            padding: 18px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 1.1em;
            font-family: 'Outfit', sans-serif;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .onboarding-input:focus {
            outline: none;
            border-color: rgba(240, 193, 75, 0.5);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 0 0 4px rgba(240, 193, 75, 0.1),
                0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .onboarding-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .onboarding-btn {
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
            color: #000;
            border: none;
            padding: 18px 48px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
            letter-spacing: 1px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .onboarding-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .onboarding-btn:hover::before {
            left: 100%;
        }

        .onboarding-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(240, 193, 75, 0.35),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .onboarding-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .onboarding-divider {
            display: flex;
            align-items: center;
            margin: 24px 0;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .onboarding-divider::before,
        .onboarding-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
        }
        
        .onboarding-divider span {
            padding: 0 16px;
        }
        
        .onboarding-recover-btn {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 14px 32px;
            border-radius: 50px;
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
        }
        
        .onboarding-recover-btn:hover {
            color: var(--accent-gold);
            border-color: rgba(240, 193, 75, 0.4);
            background: rgba(240, 193, 75, 0.1);
        }

        .join-info {
            background: rgba(240, 193, 75, 0.08);
            border: 1px solid rgba(240, 193, 75, 0.2);
            border-radius: 16px;
            padding: 18px;
            margin-bottom: 28px;
            backdrop-filter: blur(10px);
        }

        .join-info p {
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
            font-size: 0.9em;
        }

        .join-info .parent-name {
            font-weight: 600;
            font-size: 1.15em;
            color: var(--accent-gold);
            margin-top: 4px;
        }

        /* Floating Action Buttons */
        .fab-container {
            position: fixed;
            bottom: 32px;
            right: 32px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 500;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-primary);
            font-size: 22px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .fab:hover {
            transform: scale(1.1) translateY(-4px);
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.4),
                0 0 40px rgba(240, 193, 75, 0.15);
        }

        .fab.primary {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
            border: none;
            color: #000;
            font-size: 26px;
            box-shadow: 
                0 8px 32px rgba(240, 193, 75, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .fab.primary:hover {
            box-shadow: 
                0 16px 48px rgba(240, 193, 75, 0.4),
                0 0 60px rgba(240, 193, 75, 0.2);
        }

        /* QR Modal */
        #qr-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.8);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #qr-modal.active {
            display: flex;
        }

        .qr-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            color: var(--text-primary);
            text-align: center;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: modalAppear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
        }

        .qr-close {
            position: absolute;
            top: 18px;
            right: 22px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .qr-title {
            font-family: 'Syne', sans-serif;
            color: var(--text-primary);
            margin: 0 0 8px 0;
            font-size: 1.6em;
            font-weight: 700;
        }

        .qr-subtitle {
            color: var(--text-secondary);
            margin: 0 0 28px 0;
            font-size: 0.9em;
        }

        #qr-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 28px;
            min-height: 240px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #qr-display canvas,
        #qr-display img {
            border-radius: 12px;
        }

        .qr-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .qr-btn {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 14px 24px;
            border-radius: 50px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Outfit', sans-serif;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }

        .qr-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .qr-btn.primary {
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
            color: #000;
            border: none;
            font-weight: 600;
        }

        /* Node Info Modal */
        #node-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.8);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #node-modal.active {
            display: flex;
        }

        .node-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 32px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            color: var(--text-primary);
            position: relative;
            box-shadow: 
                0 24px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-align: center;
            animation: modalAppear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .node-close {
            position: absolute;
            top: 18px;
            right: 22px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .node-close:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .node-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange), var(--accent-pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            font-weight: 700;
            color: #000;
            margin: 0 auto 24px;
            box-shadow: 
                0 12px 40px rgba(240, 193, 75, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            font-family: 'Syne', sans-serif;
        }

        .node-name {
            color: var(--text-primary);
            margin: 0 0 8px 0;
            font-size: 1.8em;
            font-family: 'Syne', sans-serif;
            font-weight: 700;
        }

        .node-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 28px 0;
            padding: 24px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .node-stat {
            text-align: center;
        }

        .node-stat-value {
            font-size: 2.2em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Syne', sans-serif;
        }

        .node-stat-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }

        .node-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .node-status.online {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .node-status.offline {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .node-status.online .status-dot {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 12px currentColor;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        /* Stats Bar */
        .stats-bar {
            position: fixed;
            top: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .stat-icon {
            font-size: 1.1em;
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.15em;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        /* Your Node Indicator */
        .your-node-indicator {
            position: fixed;
            bottom: 32px;
            left: 32px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 16px 22px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .your-node-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #000;
            font-weight: 700;
            font-family: 'Syne', sans-serif;
            box-shadow: 0 4px 16px rgba(240, 193, 75, 0.3);
        }

        .your-node-info h3 {
            color: var(--text-primary);
            margin: 0 0 4px 0;
            font-size: 1.05em;
            font-weight: 600;
        }

        .your-node-info p {
            color: var(--text-secondary);
            margin: 0;
            font-size: 0.85em;
        }

        /* Loading State */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050510;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loading::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 30% 70%, rgba(168, 85, 247, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 70% 30%, rgba(255, 61, 138, 0.08) 0%, transparent 40%);
            animation: blobMove 25s ease-in-out infinite;
        }

        .loading-logo {
            font-family: 'Syne', sans-serif;
            font-size: 3.5em;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange), var(--accent-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 40px;
            letter-spacing: -2px;
            animation: glow 2.5s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }

        @keyframes glow {
            0%, 100% { 
                filter: drop-shadow(0 0 20px rgba(240, 193, 75, 0.2));
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 40px rgba(240, 193, 75, 0.4));
                transform: scale(1.02);
            }
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: relative;
            z-index: 1;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            margin-top: 24px;
            font-size: 0.9em;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }

        /* Welcome Animation for new nodes */
        .welcome-burst {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2000;
        }

        .welcome-text {
            font-family: 'Syne', sans-serif;
            font-size: 3.5em;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange), var(--accent-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: welcomeAppear 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes welcomeAppear {
            0% { 
                opacity: 0; 
                transform: scale(0.5);
                filter: blur(10px);
            }
            20% { 
                opacity: 1; 
                transform: scale(1.15);
                filter: blur(0);
            }
            40% { transform: scale(1); }
            80% { opacity: 1; }
            100% { 
                opacity: 0; 
                transform: scale(1.3);
                filter: blur(5px);
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.15);
        }
    </style>
</head>

<body>
    <div id="container"></div>
    
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loading-logo">SRISHTI</div>
        <div class="loading-spinner"></div>
        <p class="loading-text">Connecting to the timeline...</p>
    </div>

    <!-- Onboarding Modal -->
    <div id="onboarding-modal">
        <div class="onboarding-content">
            <div class="onboarding-logo">SRISHTI</div>
            <p class="onboarding-tagline">JOIN THE BLOCKCHAIN TIMELINE</p>
            
            <div id="join-parent-info" class="join-info" style="display: none;">
                <p>You're joining as a node under</p>
                <p class="parent-name" id="parent-name-display">...</p>
            </div>
            
            <div class="onboarding-input-group">
                <label for="user-name">YOUR NAME</label>
                <input type="text" id="user-name" class="onboarding-input" 
                    placeholder="Enter your name to join" maxlength="30" autocomplete="off">
            </div>
            
            <button id="join-btn" class="onboarding-btn" disabled>
                Enter the Timeline
            </button>
            
            <div class="onboarding-divider">
                <span>or</span>
            </div>
            
            <button id="recover-node-btn" class="onboarding-recover-btn">
                üîì Recover Existing Node
            </button>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div id="qr-modal">
        <div class="qr-content" style="position: relative;">
            <button class="qr-close">&times;</button>
            <h2 class="qr-title">Your Invite QR</h2>
            <p class="qr-subtitle">Others can scan this to join as your node</p>
            <div id="qr-display"></div>
            <div class="qr-actions">
                <button id="share-qr-btn" class="qr-btn primary">üì§ Share</button>
                <button id="copy-link-btn" class="qr-btn">üìã Copy Link</button>
            </div>
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                <button id="show-recovery-btn" class="qr-btn" style="width: 100%;">üîê Show Recovery Phrase</button>
            </div>
        </div>
    </div>

    <!-- Node Info Modal -->
    <div id="node-modal">
        <div class="node-content">
            <button class="node-close">&times;</button>
            <div class="node-avatar" id="node-avatar">?</div>
            <h2 class="node-name" id="node-name">Node Name</h2>
            <div class="node-status" id="node-status">
                <span class="status-dot"></span>
                <span id="node-status-text">Offline</span>
            </div>
            <div class="node-stats">
                <div class="node-stat">
                    <div class="node-stat-value" id="node-children">0</div>
                    <div class="node-stat-label">Recruited</div>
                </div>
                <div class="node-stat">
                    <div class="node-stat-value" id="node-joined">-</div>
                    <div class="node-stat-label">Joined</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar">
        <div class="stat-item">
            <span class="stat-icon">üåê</span>
            <span class="stat-value" id="total-nodes">0</span>
            <span class="stat-label">nodes</span>
        </div>
        <div class="stat-item">
            <span class="stat-icon">üü¢</span>
            <span class="stat-value" id="online-nodes">0</span>
            <span class="stat-label">online</span>
        </div>
    </div>

    <!-- Your Node Indicator -->
    <div class="your-node-indicator" id="your-node-indicator" style="display: none;">
        <div class="your-node-avatar" id="your-avatar">?</div>
        <div class="your-node-info">
            <h3 id="your-name">Your Node</h3>
            <p id="your-children">0 recruits</p>
        </div>
    </div>

    <!-- Floating Action Buttons -->
    <div class="fab-container">
        <button class="fab" id="scan-fab" title="Scan QR Code">üì∑</button>
        <button class="fab primary" id="qr-fab" title="Show Your QR">‚¨°</button>
    </div>

    <script>
        // ============================================
        // Simplex Noise Implementation
        // ============================================
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                for (let i = 0; i < 256; i++) {
                    this.p[i] = i;
                }
                
                let n, q;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 16807) % 2147483647;
                    n = seed % (i + 1);
                    q = this.p[i];
                    this.p[i] = this.p[n];
                    this.p[n] = q;
                }
                
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
                
                this.grad3 = new Float32Array([
                    1,1,0, -1,1,0, 1,-1,0, -1,-1,0,
                    1,0,1, -1,0,1, 1,0,-1, -1,0,-1,
                    0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1
                ]);
                
                this.F3 = 1.0 / 3.0;
                this.G3 = 1.0 / 6.0;
            }
            
            noise3D(x, y, z) {
                const { perm, permMod12, grad3, F3, G3 } = this;
                let n0, n1, n2, n3;
                
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                const z0 = z - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;
                
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                
                let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                if (t0 < 0) n0 = 0.0;
                else {
                    const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
                    t0 *= t0;
                    n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0+1] * y0 + grad3[gi0+2] * z0);
                }
                
                let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                if (t1 < 0) n1 = 0.0;
                else {
                    const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
                    t1 *= t1;
                    n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1+1] * y1 + grad3[gi1+2] * z1);
                }
                
                let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                if (t2 < 0) n2 = 0.0;
                else {
                    const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
                    t2 *= t2;
                    n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2+1] * y2 + grad3[gi2+2] * z2);
                }
                
                let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                if (t3 < 0) n3 = 0.0;
                else {
                    const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
                    t3 *= t3;
                    n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3+1] * y3 + grad3[gi3+2] * z3);
                }
                
                return 32.0 * (n0 + n1 + n2 + n3);
            }
        }
        
        const noise = new SimplexNoise(Math.random() * 10000);
        let noiseTime = 0;

        // ============================================
        // Application State
        // ============================================
        let currentUser = null;
        let nodesData = {};
        let nodeMeshes = [];
        let nodeDataMap = new Map();
        let unsubscribeNodes = null;

        // ============================================
        // Three.js Setup
        // ============================================
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 800);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x050510);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.03;
        controls.rotateSpeed = 0.2;
        controls.zoomSpeed = 0.4;
        controls.panSpeed = 0.3;
        controls.minDistance = 150;
        controls.maxDistance = 2000;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xFFD700, 0.8, 2000);
        pointLight1.position.set(500, 500, 500);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x4444ff, 0.4, 2000);
        pointLight2.position.set(-500, -500, 500);
        scene.add(pointLight2);

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1500;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 4000;
            starPositions[i + 1] = (Math.random() - 0.5) * 4000;
            starPositions[i + 2] = (Math.random() - 0.5) * 4000;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0x333344, size: 2, transparent: true, opacity: 0.6 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Main group for nodes
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Hover label
        let hoverLabel = null;
        
        function createLabelSprite(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = '600 34px Outfit, sans-serif';
            const textWidth = context.measureText(text).width;
            
            const padding = 36;
            const rectWidth = Math.min(textWidth + padding * 2, canvas.width - 20);
            const rectHeight = 56;
            const rectX = (canvas.width - rectWidth) / 2;
            const rectY = (canvas.height - rectHeight) / 2;
            
            // Glassmorphic background
            context.fillStyle = 'rgba(255, 255, 255, 0.12)';
            context.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            context.lineWidth = 1.5;
            
            const radius = 28;
            context.beginPath();
            context.moveTo(rectX + radius, rectY);
            context.lineTo(rectX + rectWidth - radius, rectY);
            context.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
            context.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
            context.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
            context.lineTo(rectX + radius, rectY + rectHeight);
            context.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
            context.lineTo(rectX, rectY + radius);
            context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Top highlight
            context.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(rectX + radius, rectY + 1);
            context.lineTo(rectX + rectWidth - radius, rectY + 1);
            context.stroke();
            
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                depthTest: false
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(120, 30, 1);
            sprite.visible = false;
            
            return sprite;
        }
        
        function updateLabelText(sprite, text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = '600 34px Outfit, sans-serif';
            const textWidth = context.measureText(text).width;
            
            const padding = 36;
            const rectWidth = Math.min(textWidth + padding * 2, canvas.width - 20);
            const rectHeight = 56;
            const rectX = (canvas.width - rectWidth) / 2;
            const rectY = (canvas.height - rectHeight) / 2;
            
            // Glassmorphic background
            context.fillStyle = 'rgba(255, 255, 255, 0.12)';
            context.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            context.lineWidth = 1.5;
            
            const radius = 28;
            context.beginPath();
            context.moveTo(rectX + radius, rectY);
            context.lineTo(rectX + rectWidth - radius, rectY);
            context.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
            context.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
            context.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
            context.lineTo(rectX + radius, rectY + rectHeight);
            context.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
            context.lineTo(rectX, rectY + radius);
            context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Top highlight
            context.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(rectX + radius, rectY + 1);
            context.lineTo(rectX + rectWidth - radius, rectY + 1);
            context.stroke();
            
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            sprite.material.map.dispose();
            sprite.material.map = new THREE.CanvasTexture(canvas);
            sprite.material.map.needsUpdate = true;
        }
        
        hoverLabel = createLabelSprite('');
        scene.add(hoverLabel);

        // Link objects storage
        let linkObjects = [];

        // ============================================
        // Visualization Functions
        // ============================================
        
        function buildVisualization(hierarchyData) {
            console.log(`üé® buildVisualization called with:`, hierarchyData);
            
            // Clear existing
            while (mainGroup.children.length > 0) {
                mainGroup.remove(mainGroup.children[0]);
            }
            nodeMeshes = [];
            nodeDataMap.clear();
            linkObjects = [];
            
            if (!hierarchyData) {
                console.log(`üé® No hierarchy data, returning`);
                return;
            }
            
            const root = d3.hierarchy(hierarchyData);
            const links = root.links();
            const nodes = root.descendants();
            
            console.log(`üé® Creating ${nodes.length} spheres, ${links.length} links`);
            
            // Layout
            const treeLayout = d3.tree().size([2 * Math.PI, 500]);
            treeLayout(root);
            
            // Position nodes
            nodes.forEach((d, i) => {
                const angle = d.x;
                const radius = d.y * 1.2;
                const height = (d.depth - root.height / 2) * 120;
                
                d.x3d = radius * Math.cos(angle);
                d.y3d = height;
                d.z3d = radius * Math.sin(angle);
                
                d.x = d.x3d;
                d.y = d.y3d;
                d.z = d.z3d;
                
                d.baseX = d.x;
                d.baseY = d.y;
                d.baseZ = d.z;
                d.noiseOffsetX = i * 100;
                d.noiseOffsetY = i * 100 + 1000;
                d.noiseOffsetZ = i * 100 + 2000;
                d.orbitRadius = d.children ? 15 : 25 + Math.random() * 15;
                d.orbitSpeed = 0.2 + Math.random() * 0.3;
            });
            
            // Create links
            const linkMaterial = new THREE.LineBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.3
            });
            
            links.forEach(link => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(geometry, linkMaterial.clone());
                mainGroup.add(line);
                linkObjects.push({ line, source: link.source, target: link.target });
            });
            
            // Create node meshes
            nodes.forEach(d => {
                const nodeInfo = d.data;
                const isCurrentUser = currentUser && nodeInfo.id === currentUser.id;
                const geometry = new THREE.SphereGeometry(isCurrentUser ? 20 : 15, 32, 32);
                
                // Calculate glow
                const glow = window.SrishtiGlow ? window.SrishtiGlow.calculateGlow(nodeInfo) : { intensity: 0.2, color: { r: 60, g: 60, b: 80 } };
                const color = window.SrishtiGlow ? window.SrishtiGlow.rgbToHex(glow.color) : 0x3c3c50;
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: glow.emissive || 0.2,
                    shininess: 80,
                    transparent: true,
                    opacity: 0.95
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(d.x3d, d.y3d, d.z3d);
                mesh.userData = { 
                    nodeData: nodeInfo, 
                    hierarchyNode: d,
                    isCurrentUser: isCurrentUser,
                    glow: glow
                };
                
                d.mesh = mesh;
                mainGroup.add(mesh);
                nodeMeshes.push(mesh);
                nodeDataMap.set(mesh, d);
                
                // Add corona for high-glow nodes
                if (glow.intensity > 0.6) {
                    const coronaGeometry = new THREE.SphereGeometry(isCurrentUser ? 25 : 20, 16, 16);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.15
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    mesh.add(corona);
                }
            });
            
            // Store for animation
            window.srishtiNodes = nodes;
            window.srishtiLinks = linkObjects;
        }
        
        function updateNodeGlows() {
            if (!window.SrishtiGlow) return;
            
            nodeMeshes.forEach(mesh => {
                const nodeInfo = mesh.userData.nodeData;
                if (!nodeInfo) return;
                
                // Get fresh data from nodesData
                const freshData = nodesData[nodeInfo.id];
                if (freshData) {
                    const glow = window.SrishtiGlow.calculateGlow(freshData);
                    mesh.userData.glow = glow;
                    
                    const color = window.SrishtiGlow.rgbToHex(glow.color);
                    mesh.material.color.setHex(color);
                    mesh.material.emissive.setHex(color);
                    mesh.material.emissiveIntensity = glow.emissive;
                }
            });
        }
        
        // ============================================
        // Animation
        // ============================================
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredMesh = null;
        let animationTime = 0;
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onClick(event) {
            if (event.target.closest('.fab-container') || 
                event.target.closest('#qr-modal') || 
                event.target.closest('#node-modal') ||
                event.target.closest('#onboarding-modal')) {
                return;
            }
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const nodeInfo = mesh.userData.nodeData;
                if (nodeInfo) {
                    showNodeModal(nodeInfo);
                }
            }
        }
        
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        
        function animate() {
            requestAnimationFrame(animate);
            
            animationTime += 0.016;
            noiseTime += 0.002;
            
            // Animate nodes
            if (window.srishtiNodes) {
                window.srishtiNodes.forEach(d => {
                    if (!d.parent) {
                        d.x = 0;
                        d.y = 0;
                        d.z = 0;
                        if (d.mesh) d.mesh.position.set(0, 0, 0);
                        return;
                    }
                    
                    const t = noiseTime * d.orbitSpeed;
                    const noiseX = noise.noise3D(d.noiseOffsetX * 0.01, t, 0);
                    const noiseY = noise.noise3D(d.noiseOffsetY * 0.01, t, 0);
                    const noiseZ = noise.noise3D(d.noiseOffsetZ * 0.01, t, 0);
                    
                    const offsetX = noiseX * d.orbitRadius;
                    const offsetY = noiseY * d.orbitRadius;
                    const offsetZ = noiseZ * d.orbitRadius;
                    
                    const targetX = d.baseX + offsetX;
                    const targetY = d.baseY + offsetY;
                    const targetZ = d.baseZ + offsetZ;
                    
                    const smoothing = 0.03;
                    d.x += (targetX - d.x) * smoothing;
                    d.y += (targetY - d.y) * smoothing;
                    d.z += (targetZ - d.z) * smoothing;
                    
                    if (d.mesh) {
                        d.mesh.position.set(d.x, d.y, d.z);
                        
                        // Pulse effect for online nodes
                        const glow = d.mesh.userData.glow;
                        if (glow && glow.pulse) {
                            const pulse = Math.sin(animationTime * glow.pulseSpeed * 2) * 0.2 + 0.8;
                            d.mesh.material.emissiveIntensity = glow.emissive * pulse;
                        }
                    }
                });
            }
            
            // Update links
            if (window.srishtiLinks) {
                window.srishtiLinks.forEach(({ line, source, target }) => {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = source.x;
                    positions[1] = source.y;
                    positions[2] = source.z;
                    positions[3] = target.x;
                    positions[4] = target.y;
                    positions[5] = target.z;
                    line.geometry.attributes.position.needsUpdate = true;
                    
                    // Glow links between online nodes
                    const sourceOnline = source.data && source.data.isOnline;
                    const targetOnline = target.data && target.data.isOnline;
                    if (sourceOnline && targetOnline) {
                        line.material.opacity = 0.6;
                    } else if (sourceOnline || targetOnline) {
                        line.material.opacity = 0.4;
                    } else {
                        line.material.opacity = 0.2;
                    }
                });
            }
            
            // Hover detection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (hoveredMesh && (!intersects.length || intersects[0].object !== hoveredMesh)) {
                hoveredMesh.scale.set(1, 1, 1);
                hoveredMesh = null;
                hoverLabel.visible = false;
                document.body.style.cursor = 'default';
            }
            
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                if (mesh !== hoveredMesh) {
                    hoveredMesh = mesh;
                    mesh.scale.set(1.2, 1.2, 1.2);
                    
                    const nodeData = mesh.userData.nodeData;
                    if (nodeData) {
                        updateLabelText(hoverLabel, nodeData.name || 'Unknown');
                        hoverLabel.visible = true;
                    }
                    document.body.style.cursor = 'pointer';
                }
                
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                hoverLabel.position.copy(worldPos);
                hoverLabel.position.y += 35;
            }
            
            stars.rotation.y += 0.0001;
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ============================================
        // UI Functions
        // ============================================
        
        function showOnboardingModal(parentId = null) {
            const modal = document.getElementById('onboarding-modal');
            const joinInfo = document.getElementById('join-parent-info');
            const parentDisplay = document.getElementById('parent-name-display');
            const joinBtn = document.getElementById('join-btn');
            const nameInput = document.getElementById('user-name');
            const recoverBtn = document.getElementById('recover-node-btn');
            
            // Check if joining under a parent
            if (parentId && nodesData[parentId]) {
                joinInfo.style.display = 'block';
                parentDisplay.textContent = nodesData[parentId].name || 'A node';
            } else {
                joinInfo.style.display = 'none';
            }
            
            // Store parent ID for later
            modal.dataset.parentId = parentId || '';
            
            // Enable/disable button based on input
            nameInput.value = '';
            joinBtn.disabled = true;
            
            nameInput.oninput = () => {
                joinBtn.disabled = nameInput.value.trim().length < 2;
            };
            
            joinBtn.onclick = async () => {
                const name = nameInput.value.trim();
                if (name.length < 2) return;
                
                joinBtn.disabled = true;
                joinBtn.textContent = 'Joining...';
                
                await joinNetwork(name, modal.dataset.parentId || null);
            };
            
            // Recovery button handler
            recoverBtn.onclick = () => {
                if (window.SrishtiRecovery) {
                    window.SrishtiRecovery.init();
                    window.SrishtiRecovery.showRecoverInputModal(handleRecoveredNode);
                }
            };
            
            modal.classList.add('active');
            setTimeout(() => nameInput.focus(), 100);
        }
        
        async function handleRecoveredNode(recoveryData) {
            const { phrase, name } = recoveryData;
            
            try {
                // Search the chain for a node with matching phrase hash
                const phraseHash = await window.SrishtiRecovery.hashPhrase(phrase);
                const nodes = window.SrishtiApp.chain.buildNodeMap();
                
                // For now, look for any node with matching recovery hash
                // In a full implementation, we'd derive the key from the phrase
                let foundNode = null;
                for (const [nodeId, node] of Object.entries(nodes)) {
                    if (node.recoveryPhraseHash === phraseHash) {
                        foundNode = { id: nodeId, ...node };
                        break;
                    }
                }
                
                if (!foundNode) {
                    // Recovery phrase doesn't match any known node
                    // Show explanation and offer to join as new node
                    alert('Recovery phrase not found in the network.\n\nNote: Recovery works best when restoring on a device that previously had the node. For now, you can join as a new node.');
                    return;
                }
                
                // Set current user
                currentUser = { id: foundNode.id, name: foundNode.name || name };
                
                // Save to localStorage
                localStorage.setItem('srishti_node_id', foundNode.id);
                localStorage.setItem('srishti_node_name', foundNode.name || name);
                
                // Initialize QR
                if (window.SrishtiQRCode && foundNode.publicKey) {
                    window.SrishtiQRCode.init(foundNode.id, foundNode.publicKey);
                }
                
                hideOnboardingModal();
                showWelcome(foundNode.name || name);
                
                console.log('‚úÖ Recovered node:', foundNode.name, foundNode.id);
            } catch (error) {
                console.error('Recovery failed:', error);
                alert('Recovery failed. Please try again or join as a new node.');
            }
        }
        
        function hideOnboardingModal() {
            document.getElementById('onboarding-modal').classList.remove('active');
        }
        
        function showQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.add('active');
            
            // Generate QR
            if (window.SrishtiQRCode && currentUser && window.SrishtiApp.publicKeyBase64) {
                window.SrishtiQRCode.init(currentUser.id, window.SrishtiApp.publicKeyBase64);
                window.SrishtiQRCode.generateQR('qr-display');
            }
        }
        
        function hideQRModal() {
            document.getElementById('qr-modal').classList.remove('active');
        }
        
        function showNodeModal(nodeData) {
            const modal = document.getElementById('node-modal');
            
            document.getElementById('node-avatar').textContent = (nodeData.name || '?')[0].toUpperCase();
            document.getElementById('node-name').textContent = nodeData.name || 'Unknown';
            document.getElementById('node-children').textContent = nodeData.childCount || 0;
            
            const statusEl = document.getElementById('node-status');
            const statusText = document.getElementById('node-status-text');
            if (nodeData.isOnline) {
                statusEl.className = 'node-status online';
                statusText.textContent = 'Online';
            } else {
                statusEl.className = 'node-status offline';
                statusText.textContent = 'Offline';
            }
            
            // Format join date
            if (nodeData.createdAt) {
                const date = new Date(nodeData.createdAt);
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) {
                    document.getElementById('node-joined').textContent = 'Today';
                } else if (diffDays === 1) {
                    document.getElementById('node-joined').textContent = 'Yesterday';
                } else if (diffDays < 30) {
                    document.getElementById('node-joined').textContent = `${diffDays}d ago`;
                } else {
                    document.getElementById('node-joined').textContent = date.toLocaleDateString();
                }
            } else {
                document.getElementById('node-joined').textContent = '-';
            }
            
            modal.classList.add('active');
        }
        
        function hideNodeModal() {
            document.getElementById('node-modal').classList.remove('active');
        }
        
        function updateStats() {
            const nodes = Object.values(nodesData).filter(n => !n.isVirtualRoot);
            console.log(`üìä updateStats: ${nodes.length} nodes, currentUser:`, currentUser);
            
            document.getElementById('total-nodes').textContent = nodes.length;
            document.getElementById('online-nodes').textContent = nodes.filter(n => n.isOnline).length;
            
            // Update your node indicator
            if (currentUser) {
                const indicator = document.getElementById('your-node-indicator');
                const freshData = nodesData[currentUser.id];
                console.log(`üìä User data for ${currentUser.id}:`, freshData);
                
                // Use chain data if available, otherwise fallback to currentUser data
                const displayName = freshData?.name || currentUser.name || '?';
                const childCount = freshData?.childCount || 0;
                
                document.getElementById('your-avatar').textContent = displayName[0].toUpperCase();
                document.getElementById('your-name').textContent = displayName;
                document.getElementById('your-children').textContent = `${childCount} recruits`;
                indicator.style.display = 'flex';
                console.log(`‚úÖ Profile indicator set to visible for ${displayName}`);
                
                if (!freshData) {
                    console.log(`‚ö†Ô∏è Node ${currentUser.id} not in chain yet, using localStorage data`);
                }
            } else {
                console.log(`‚ö†Ô∏è currentUser is not set`);
            }
        }
        
        function showWelcome(name) {
            const burst = document.createElement('div');
            burst.className = 'welcome-burst';
            burst.innerHTML = `<div class="welcome-text">Welcome, ${name}!</div>`;
            document.body.appendChild(burst);
            
            setTimeout(() => burst.remove(), 2500);
        }
        
        // ============================================
        // Network Functions
        // ============================================
        
        async function joinNetwork(name, parentId) {
            try {
                const result = await window.SrishtiApp.createNode(name, parentId);
                const nodeId = result.nodeId;
                const recoveryPhrase = result.recoveryPhrase;
                
                currentUser = { id: nodeId, name: name };
                
                // Update stats immediately now that currentUser is set
                updateStats();
                
                // Mark ourselves as online
                if (window.SrishtiApp) {
                    window.SrishtiApp.updatePresence(nodeId, { isOnline: true, lastSeen: Date.now() });
                }
                
                // Initialize QR
                if (window.SrishtiQRCode && window.SrishtiApp.publicKeyBase64) {
                    window.SrishtiQRCode.init(nodeId, window.SrishtiApp.publicKeyBase64);
                }
                
                // Clear join param from URL
                const url = new URL(window.location.href);
                url.searchParams.delete('join');
                window.history.replaceState({}, document.title, url.pathname);
                
                hideOnboardingModal();
                
                // Show recovery phrase FIRST, then welcome
                if (window.SrishtiRecovery && recoveryPhrase) {
                    window.SrishtiRecovery.showPhraseModal(recoveryPhrase, () => {
                        showWelcome(name);
                    });
                } else {
                    showWelcome(name);
                }
                
                console.log('‚úÖ Joined network as:', name, nodeId);
            } catch (error) {
                console.error('Failed to join network:', error);
                alert('Failed to join. Please try again.');
                document.getElementById('join-btn').disabled = false;
                document.getElementById('join-btn').textContent = 'Enter the Timeline';
            }
        }
        
        async function handleScannedQR(parentId) {
            // Verify parent exists
            const parentExists = window.SrishtiApp.nodeExists(parentId);
            if (!parentExists) {
                alert('Invalid QR code. The node does not exist.');
                return;
            }
            
            // If already in network, just show info
            if (currentUser) {
                const parentData = nodesData[parentId];
                alert(`This is ${parentData?.name || 'a node'}'s invite QR. You're already in the network!`);
                return;
            }
            
            // Show onboarding with parent
            showOnboardingModal(parentId);
        }
        
        // ============================================
        // Initialization
        // ============================================
        
        async function init() {
            // Initialize blockchain app
            try {
                await window.SrishtiApp.init();
            } catch (error) {
                console.error('Failed to initialize blockchain:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="loading-logo">SRISHTI</div>
                    <p style="color: #FFD700; margin-top: 20px;">‚ö†Ô∏è Blockchain initialization failed</p>
                    <p style="color: #888; font-size: 0.9em;">${error.message}</p>
                `;
                return;
            }
            
            // Check for join parameter in URL
            const urlParams = new URLSearchParams(window.location.search);
            const joinParam = urlParams.get('join');
            let joinParentId = null;
            
            if (joinParam) {
                try {
                    const connectionInfo = window.SrishtiQRCodeClass.parseFromUrl(joinParam);
                    if (connectionInfo) {
                        joinParentId = connectionInfo.nodeId;
                    }
                } catch (e) {
                    console.warn('Failed to parse join param:', e);
                }
            }
            
            // Check for existing user
            const savedNodeId = localStorage.getItem('srishti_node_id');
            const savedNodeName = localStorage.getItem('srishti_node_name');
            
            // Subscribe to nodes (same interface as Firebase!)
            unsubscribeNodes = window.SrishtiApp.subscribeToNodes((nodes) => {
                console.log(`üîî Node update received: ${Object.keys(nodes).length} nodes`);
                nodesData = nodes;
                updateStats();
                
                // Build visualization
                const hierarchy = window.SrishtiApp.buildHierarchy();
                console.log(`üå≥ Hierarchy built:`, hierarchy ? 'has data' : 'null');
                buildVisualization(hierarchy);
                
                // Update glows periodically
                updateNodeGlows();
            });
            
            // Wait a moment for initial data
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Check if returning user - trust localStorage if we have valid data
            const hasValidLocalData = savedNodeId && savedNodeName && localStorage.getItem('srishti_private_key');
            console.log(`üîç Checking returning user: savedNodeId=${savedNodeId}, hasValidLocalData=${hasValidLocalData}`);
            
            if (hasValidLocalData) {
                // User has valid identity in localStorage - they're a returning user
                currentUser = { id: savedNodeId, name: savedNodeName };
                console.log(`‚úÖ Returning user set: ${savedNodeName} (${savedNodeId})`);
                
                // Mark ourselves as online
                if (window.SrishtiApp) {
                    window.SrishtiApp.updatePresence(savedNodeId, { isOnline: true, lastSeen: Date.now() });
                }
                
                // Initialize QR
                if (window.SrishtiQRCode && window.SrishtiApp.publicKeyBase64) {
                    window.SrishtiQRCode.init(savedNodeId, window.SrishtiApp.publicKeyBase64);
                }
                
                // If they came from a QR link but are already in network
                if (joinParentId) {
                    const url = new URL(window.location.href);
                    url.searchParams.delete('join');
                    window.history.replaceState({}, document.title, url.pathname);
                }
                
                // Trigger a UI update with current user
                updateStats();
            } else if (joinParentId) {
                // New user joining via QR
                showOnboardingModal(joinParentId);
            } else {
                // New user, no parent (root node)
                showOnboardingModal(null);
            }
            
            // Start animation
            animate();
            
            // Update glows every 5 seconds
            setInterval(updateNodeGlows, 5000);
        }
        
        // ============================================
        // Event Listeners
        // ============================================
        
        // FAB buttons
        document.getElementById('qr-fab').addEventListener('click', showQRModal);
        document.getElementById('scan-fab').addEventListener('click', () => {
            if (window.SrishtiScanner) {
                window.SrishtiScanner.init(handleScannedQR);
                window.SrishtiScanner.open();
            }
        });
        
        // QR Modal buttons
        document.querySelector('#qr-modal .qr-close').addEventListener('click', hideQRModal);
        document.getElementById('share-qr-btn').addEventListener('click', () => {
            window.SrishtiQRCode && window.SrishtiQRCode.shareInviteUrl();
        });
        document.getElementById('copy-link-btn').addEventListener('click', async () => {
            if (window.SrishtiQRCode) {
                await window.SrishtiQRCode.copyInviteUrl();
            }
        });
        
        document.getElementById('show-recovery-btn').addEventListener('click', () => {
            const privateKey = localStorage.getItem('srishti_private_key');
            if (privateKey && window.SrishtiRecovery) {
                const phrase = window.SrishtiRecovery.generatePhrase(privateKey);
                window.SrishtiRecovery.showPhraseModal(phrase);
            } else {
                alert('No recovery phrase available');
            }
        });
        
        // Node Modal
        document.querySelector('#node-modal .node-close').addEventListener('click', hideNodeModal);
        document.getElementById('node-modal').addEventListener('click', (e) => {
            if (e.target.id === 'node-modal') hideNodeModal();
        });
        
        // QR Modal backdrop
        document.getElementById('qr-modal').addEventListener('click', (e) => {
            if (e.target.id === 'qr-modal') hideQRModal();
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start
        init();
    </script>
</body>

</html>
